<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    
      <title>
        var 在 JavaScript 循环中的问题 | Leodots
      </title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style type="text/css" data-styled-components="djiuUw ehFhRk bjznky ehsBOr cKUUOL bUfeR dQozFt bxrUCS hBdBXi gQextd" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {}

.djiuUw{display:block;text-align:center;padding:0;margin:0;padding-top:30px;list-style:none;height:55px;margin-left:calc(100vw - 100%);}@media screen and (max-width:770px){.djiuUw{display:none;}}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {}

.ehFhRk{text-align:center;font-size:18px;margin:0 25px;display:inline-block;}.ehFhRk:hover{border-bottom:2px solid #222;}.ehFhRk > a{-webkit-text-decoration:none;text-decoration:none;color:#222;}
/* sc-component-id: sc-htpNat */
.sc-htpNat {}

.bjznky{position:relative;}@media screen and (min-width:770px){.bjznky{display:none;}}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {}

.ehsBOr{text-align:center;background-color:#464d5c;color:#fff;padding:40px 10px;font-size:40px;}
/* sc-component-id: sc-ifAKCX */
.sc-ifAKCX {}

.cKUUOL{color:#bee178;}
/* sc-component-id: sc-EHOje */
.sc-EHOje {}

.bUfeR{position:absolute;right:0px;padding:19px 19px;top:0px;border-radius:50%;background-color:transparent;border-color:transparent;-webkit-transition:0.5s background-color;transition:0.5s background-color;}
/* sc-component-id: sc-bZQynM */
.sc-bZQynM {}

.dQozFt{height:2px;width:18px;margin-bottom:3px;display:block;background-color:#bee178;}
/* sc-component-id: sc-gzVnrw */
.sc-gzVnrw {}

.bxrUCS{position:absolute;right:20px;top:42px;width:150px;height:125px;background-color:#fff;box-shadow:rgba(0,0,0,0.117647) 0 1px 6px, rgba(0,0,0,0.239216) 0 1px 4px;-webkit-transition:0.2s;transition:0.2s;overflow:hidden;padding:10px 0;}.bxrUCS > li{list-style:none;}.bxrUCS > li > a{-webkit-text-decoration:none;text-decoration:none;color:#777;display:block;padding:10px 20px;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {}

.hBdBXi{position:absolute;bottom:20px;left:0;right:0;text-align:center;font-size:12px;}
/* sc-component-id: sc-dnqmqq */
.sc-dnqmqq {}

.gQextd{color:#999;}.gQextd > a{color:#bee178 !important;-webkit-text-decoration:none;text-decoration:none;}@media screen and (min-width:770px){.gQextd > a{color:#108ee9 !important;-webkit-text-decoration:underline;text-decoration:underline;}}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1576189413 */
html{position:relative;background-color:#464d5c;font-family:'PingFang SC','Hiragino Sans GB','Microsoft Yahei','WenQuanYi Micro Hei',sans-serif;}@media screen and (min-width:770px){html{background-color:#ECF0F1;}}html,body{min-height:100vh;margin:0;padding:0;}#app{min-height:100vh;}
</style><style type="text/css" data-styled-components="gkwKrD gIWTme iLKjzi fCjyQ kqQANZ frgWBf OaFaI" data-styled-components-is-local="true">/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {}

.gkwKrD{position:relative;min-height:100vh;}
/* sc-component-id: sc-gZMcBi */
.sc-gZMcBi {}

.gIWTme{padding-bottom:60px;}@media screen and (min-width:770px){.gIWTme{padding:0px 0 100px;margin-left:calc(100vw - 100%);}}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {}

.iLKjzi{padding:20px 15px 25px;background-color:#fff;}@media screen and (min-width:770px){.iLKjzi{box-sizing:border-box;width:768px;margin:0 auto;padding-left:40px;padding-right:40px;box-shadow:0px 30px 60px 0px #d3dde2;}}
/* sc-component-id: sc-VigVT */
.sc-VigVT {}

.kqQANZ{margin-top:0;margin-bottom:30px;text-align:center;font-size:24px;}@media screen and (min-width:770px){.kqQANZ{font-size:30px;}}
/* sc-component-id: sc-jTzLTM */
.sc-jTzLTM {}

.frgWBf{text-align:center;color:#999;margin-top:50px;font-size:12px;-webkit-text-decoration:underline;text-decoration:underline;}
/* sc-component-id: sc-fjdhpX */
.sc-fjdhpX {}

.OaFaI{background-color:#fff;padding-top:60px;}
/* sc-component-id: sc-jzJRlG */
.sc-jzJRlG {}

.fCjyQ{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.fCjyQ{min-height:500px;}.fCjyQ a:hover{-webkit-text-decoration:underline;text-decoration:underline;cursor:pointer;}}.fCjyQ a{color:#3194d0;}.fCjyQ p,.fCjyQ li{line-height:1.8;}.fCjyQ img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.fCjyQ img{max-width:500px;}}.fCjyQ code{background:#f2f2f2;padding:2px 5px;}.fCjyQ pre{background:#f2f2f2;padding:20px;overflow-x:auto;line-height:1.8;}.fCjyQ pre > code{padding:0;}.fCjyQ blockquote{margin-left:0;padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}
</style>
</head>

<body>
    <div id="app"><div class="sc-iwsKbI gkwKrD" data-reactroot=""><div><ul class="sc-bdVaJa djiuUw"><li class="sc-bwzfXH ehFhRk"><a href="/">首页</a></li><li class="sc-bwzfXH ehFhRk"><a href="/archive.html">归档</a></li><li class="sc-bwzfXH ehFhRk"><a href="/about.html">关于</a></li></ul><div class="sc-htpNat bjznky"><div class="sc-bxivhb ehsBOr"><span class="sc-ifAKCX cKUUOL">&lt;Leodots /&gt;</span></div><button class="sc-EHOje bUfeR"><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span></button><ul class="sc-gzVnrw bxrUCS" style="width:0;height:0"><li><a href="/">首页</a></li><li><a href="/archive.html">归档</a></li><li><a href="/about.html">关于</a></li></ul></div></div><div class="sc-gZMcBi gIWTme"><div class="sc-gqjmRU iLKjzi"><div class="sc-jzJRlG fCjyQ"><div class="sc-VigVT kqQANZ">var 在 JavaScript 循环中的问题</div><div class="sc-jzJRlG fCjyQ"><p>这个问题也是 JS 里面比较经典的问题，在网上也有很多回答。下午又偶然看到，重新想了一下，感觉才真正明白为什么。先看具体的例子</p>
<pre><code class="js language-js">var helpText = [
  { id: "email", help: "Your e-mail address" },
  { id: "name", help: "Your full name" },
  { id: "age", help: "Your age (you must be over 16)" }
];

const cbs = [];

for (var i = 0; i &lt; helpText.length; i++) {
  var item = helpText[i];
  cbs.push(function() {
    console.log(item.id);
  });
}

cbs.forEach(cb =&gt; cb());
// age
// age
// age
</code></pre>
<p>上面的输出都是 <code>age</code>，而没有我们期望的 <code>email</code> 和 <code>name</code>。开始分析这个问题前，需要知道两点</p>
<ul>
<li><code>var</code> 的作用域是什么</li>
<li>在同一个作用域内，多次重复声明会发生什么事情</li>
</ul>
<p>先来看第一点</p>
<blockquote>
  <p>The scope of a variable declared with var is its current execution context, which is either the enclosing function or, for variables declared outside any function, global.</p>
</blockquote>
<p>根据 MDN 的文档可以知道，<code>var</code> 的作用域只限定在函数或者全局当中。<code>for</code>，<code>while</code>，<code>if</code> 这些并不会重新创建作用域。</p>
<blockquote>
  <p>If you re-declare a JavaScript variable, it will not lose its value.</p>
</blockquote>
<p>也是文档中的描述，说明了在同个作用域内，是允许多次重复声明的。</p>
<pre><code class="js language-js">var age = 1;
console.log(age);
var age = 2;
console.log(age);
var age = 3;
console.log(age);

// 1
// 2
// 3
</code></pre>
<p>之所以能这样做，也是因为 <code>var</code> 存在变量提升，不过这里就不展开说。只要知道能重复定义就行。所以文章一开始的例子，可以用下面更直观的形式展现</p>
<pre><code class="js language-js">var helpText = [
  { id: "email", help: "Your e-mail address" },
  { id: "name", help: "Your full name" },
  { id: "age", help: "Your age (you must be over 16)" }
];

const cbs = [];

var item = helpText[0];
cbs.push(function() {
  console.log(item.id);
});
var item = helpText[1];
cbs.push(function() {
  console.log(item.id);
});
var item = helpText[2];
cbs.push(function() {
  console.log(item.id);
});

cbs.forEach(cb =&gt; cb());
</code></pre>
<p>数组里面的三个函数都是指向同一个 <code>item</code>，而 <code>item</code> 最终是指向 <code>helpText</code> 里面的最后一个元素。</p>
<p>在 ES6 引入的 <code>let</code> 可以很好地解决这个问题，所以如果你平时都是用 <code>let</code> 的话，也不会遇到这种情况。不过这里我们还是看下 babel 是怎样处理的</p>
<pre><code class="js language-js">"use strict";

var helpText = [
  { id: "email", help: "Your e-mail address" },
  { id: "name", help: "Your full name" },
  { id: "age", help: "Your age (you must be over 16)" }
];

var cbs = [];

var _loop = function _loop() {
  var item = helpText[i];
  cbs.push(function() {
    console.log(item.id);
  });
};

for (var i = 0; i &lt; helpText.length; i++) {
  _loop();
}

cbs.forEach(function(cb) {
  return cb();
});
</code></pre>
<p>上面是把 <code>item</code> 换成 <code>let</code> 声明之后，babel 转换的代码。可以看到，这里把循环的内容放到一个 <code>_loop</code> 函数里面，从而给每个 <code>item</code> 创建一个独立的作用域。</p>
<p>（完）</p></div><div class="sc-jTzLTM frgWBf">2018.07.22</div></div><div class="sc-fjdhpX OaFaI" id="disqus_thread"></div></div></div><div class="sc-htoDjs hBdBXi"><span class="sc-dnqmqq gQextd">Powered by <a href="https://github.com/clinyong/cubi">Cubi</a>,  </span><span class="sc-dnqmqq gQextd">Hosted by <a href="https://pages.coding.me">Coding Pages</a></span></div></div></div>
    
      <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
              navigator.serviceWorker.register('/sw.js');
            });
          }
      </script>
      
    <script>
		
    </script>
    <script>
		var INIT_PROPS = {"content":{"meta":{"title":"var 在 JavaScript 循环中的问题","date":"2018.07.22"},"content":"\n这个问题也是 JS 里面比较经典的问题，在网上也有很多回答。下午又偶然看到，重新想了一下，感觉才真正明白为什么。先看具体的例子\n\n```js\nvar helpText = [\n  { id: \"email\", help: \"Your e-mail address\" },\n  { id: \"name\", help: \"Your full name\" },\n  { id: \"age\", help: \"Your age (you must be over 16)\" }\n];\n\nconst cbs = [];\n\nfor (var i = 0; i &lt; helpText.length; i++) {\n  var item = helpText[i];\n  cbs.push(function() {\n    console.log(item.id);\n  });\n}\n\ncbs.forEach(cb =&gt; cb());\n// age\n// age\n// age\n```\n\n上面的输出都是 `age`，而没有我们期望的 `email` 和 `name`。开始分析这个问题前，需要知道两点\n\n- `var` 的作用域是什么\n- 在同一个作用域内，多次重复声明会发生什么事情\n\n先来看第一点\n\n> The scope of a variable declared with var is its current execution context, which is either the enclosing function or, for variables declared outside any function, global.\n\n根据 MDN 的文档可以知道，`var` 的作用域只限定在函数或者全局当中。`for`，`while`，`if` 这些并不会重新创建作用域。\n\n> If you re-declare a JavaScript variable, it will not lose its value.\n\n也是文档中的描述，说明了在同个作用域内，是允许多次重复声明的。\n\n```js\nvar age = 1;\nconsole.log(age);\nvar age = 2;\nconsole.log(age);\nvar age = 3;\nconsole.log(age);\n\n// 1\n// 2\n// 3\n```\n\n之所以能这样做，也是因为 `var` 存在变量提升，不过这里就不展开说。只要知道能重复定义就行。所以文章一开始的例子，可以用下面更直观的形式展现\n\n```js\nvar helpText = [\n  { id: \"email\", help: \"Your e-mail address\" },\n  { id: \"name\", help: \"Your full name\" },\n  { id: \"age\", help: \"Your age (you must be over 16)\" }\n];\n\nconst cbs = [];\n\nvar item = helpText[0];\ncbs.push(function() {\n  console.log(item.id);\n});\nvar item = helpText[1];\ncbs.push(function() {\n  console.log(item.id);\n});\nvar item = helpText[2];\ncbs.push(function() {\n  console.log(item.id);\n});\n\ncbs.forEach(cb => cb());\n```\n\n数组里面的三个函数都是指向同一个 `item`，而 `item` 最终是指向 `helpText` 里面的最后一个元素。\n\n在 ES6 引入的 `let` 可以很好地解决这个问题，所以如果你平时都是用 `let` 的话，也不会遇到这种情况。不过这里我们还是看下 babel 是怎样处理的\n\n```js\n\"use strict\";\n\nvar helpText = [\n  { id: \"email\", help: \"Your e-mail address\" },\n  { id: \"name\", help: \"Your full name\" },\n  { id: \"age\", help: \"Your age (you must be over 16)\" }\n];\n\nvar cbs = [];\n\nvar _loop = function _loop() {\n  var item = helpText[i];\n  cbs.push(function() {\n    console.log(item.id);\n  });\n};\n\nfor (var i = 0; i &lt; helpText.length; i++) {\n  _loop();\n}\n\ncbs.forEach(function(cb) {\n  return cb();\n});\n```\n\n上面是把 `item` 换成 `let` 声明之后，babel 转换的代码。可以看到，这里把循环的内容放到一个 `_loop` 函数里面，从而给每个 `item` 创建一个独立的作用域。\n\n（完）\n"}};
    </script>
    
    <script src=/js/vendors.094c268b.dll.js></script>
    
    <script src=/js/__post.a85ba19a.dll.js></script>
    
    <script src=/js/post.cb81a6af.js></script>
    
</body>

</html>
