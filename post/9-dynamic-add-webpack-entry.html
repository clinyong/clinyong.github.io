<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    
      <title>
        动态加载 webpack entry | Leodots
      </title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style type="text/css" data-styled-components="djiuUw ehFhRk bjznky ehsBOr cKUUOL bUfeR dQozFt bxrUCS hBdBXi gQextd" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {}

.djiuUw{display:block;text-align:center;padding:0;margin:0;padding-top:30px;list-style:none;height:55px;margin-left:calc(100vw - 100%);}@media screen and (max-width:770px){.djiuUw{display:none;}}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {}

.ehFhRk{text-align:center;font-size:18px;margin:0 25px;display:inline-block;}.ehFhRk:hover{border-bottom:2px solid #222;}.ehFhRk > a{-webkit-text-decoration:none;text-decoration:none;color:#222;}
/* sc-component-id: sc-htpNat */
.sc-htpNat {}

.bjznky{position:relative;}@media screen and (min-width:770px){.bjznky{display:none;}}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {}

.ehsBOr{text-align:center;background-color:#464d5c;color:#fff;padding:40px 10px;font-size:40px;}
/* sc-component-id: sc-ifAKCX */
.sc-ifAKCX {}

.cKUUOL{color:#bee178;}
/* sc-component-id: sc-EHOje */
.sc-EHOje {}

.bUfeR{position:absolute;right:0px;padding:19px 19px;top:0px;border-radius:50%;background-color:transparent;border-color:transparent;-webkit-transition:0.5s background-color;transition:0.5s background-color;}
/* sc-component-id: sc-bZQynM */
.sc-bZQynM {}

.dQozFt{height:2px;width:18px;margin-bottom:3px;display:block;background-color:#bee178;}
/* sc-component-id: sc-gzVnrw */
.sc-gzVnrw {}

.bxrUCS{position:absolute;right:20px;top:42px;width:150px;height:125px;background-color:#fff;box-shadow:rgba(0,0,0,0.117647) 0 1px 6px, rgba(0,0,0,0.239216) 0 1px 4px;-webkit-transition:0.2s;transition:0.2s;overflow:hidden;padding:10px 0;}.bxrUCS > li{list-style:none;}.bxrUCS > li > a{-webkit-text-decoration:none;text-decoration:none;color:#777;display:block;padding:10px 20px;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {}

.hBdBXi{position:absolute;bottom:20px;left:0;right:0;text-align:center;font-size:12px;}
/* sc-component-id: sc-dnqmqq */
.sc-dnqmqq {}

.gQextd{color:#999;}.gQextd > a{color:#bee178 !important;-webkit-text-decoration:none;text-decoration:none;}@media screen and (min-width:770px){.gQextd > a{color:#108ee9 !important;-webkit-text-decoration:underline;text-decoration:underline;}}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1576189413 */
html{position:relative;background-color:#464d5c;font-family:'PingFang SC','Hiragino Sans GB','Microsoft Yahei','WenQuanYi Micro Hei',sans-serif;}@media screen and (min-width:770px){html{background-color:#ECF0F1;}}html,body{min-height:100vh;margin:0;padding:0;}#app{min-height:100vh;}
</style><style type="text/css" data-styled-components="gkwKrD gIWTme iLKjzi fCjyQ kqQANZ frgWBf OaFaI" data-styled-components-is-local="true">/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {}

.gkwKrD{position:relative;min-height:100vh;}
/* sc-component-id: sc-gZMcBi */
.sc-gZMcBi {}

.gIWTme{padding-bottom:60px;}@media screen and (min-width:770px){.gIWTme{padding:0px 0 100px;margin-left:calc(100vw - 100%);}}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {}

.iLKjzi{padding:20px 15px 25px;background-color:#fff;}@media screen and (min-width:770px){.iLKjzi{box-sizing:border-box;width:768px;margin:0 auto;padding-left:40px;padding-right:40px;box-shadow:0px 30px 60px 0px #d3dde2;}}
/* sc-component-id: sc-VigVT */
.sc-VigVT {}

.kqQANZ{margin-top:0;margin-bottom:30px;text-align:center;font-size:24px;}@media screen and (min-width:770px){.kqQANZ{font-size:30px;}}
/* sc-component-id: sc-jTzLTM */
.sc-jTzLTM {}

.frgWBf{text-align:center;color:#999;margin-top:50px;font-size:12px;-webkit-text-decoration:underline;text-decoration:underline;}
/* sc-component-id: sc-fjdhpX */
.sc-fjdhpX {}

.OaFaI{background-color:#fff;padding-top:60px;}
/* sc-component-id: sc-jzJRlG */
.sc-jzJRlG {}

.fCjyQ{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.fCjyQ{min-height:500px;}.fCjyQ a:hover{-webkit-text-decoration:underline;text-decoration:underline;cursor:pointer;}}.fCjyQ a{color:#3194d0;}.fCjyQ p,.fCjyQ li{line-height:1.8;}.fCjyQ img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.fCjyQ img{max-width:500px;}}.fCjyQ code{background:#f2f2f2;padding:2px 5px;}.fCjyQ pre{background:#f2f2f2;padding:20px;overflow-x:auto;line-height:1.8;}.fCjyQ pre > code{padding:0;}.fCjyQ blockquote{margin-left:0;padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}
</style>
</head>

<body>
    <div id="app"><div class="sc-iwsKbI gkwKrD" data-reactroot=""><div><ul class="sc-bdVaJa djiuUw"><li class="sc-bwzfXH ehFhRk"><a href="/">首页</a></li><li class="sc-bwzfXH ehFhRk"><a href="/archive.html">归档</a></li><li class="sc-bwzfXH ehFhRk"><a href="/about.html">关于</a></li></ul><div class="sc-htpNat bjznky"><div class="sc-bxivhb ehsBOr"><span class="sc-ifAKCX cKUUOL">&lt;Leodots /&gt;</span></div><button class="sc-EHOje bUfeR"><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span></button><ul class="sc-gzVnrw bxrUCS" style="width:0;height:0"><li><a href="/">首页</a></li><li><a href="/archive.html">归档</a></li><li><a href="/about.html">关于</a></li></ul></div></div><div class="sc-gZMcBi gIWTme"><div class="sc-gqjmRU iLKjzi"><div class="sc-jzJRlG fCjyQ"><div class="sc-VigVT kqQANZ">动态加载 webpack entry</div><div class="sc-jzJRlG fCjyQ"><p>在多页面的项目中，一般我们会把每个页面作为一个 webpack 的 entry，比如像下面这样的配置文件</p>
<pre><code class="js language-js">module.exports = {
    entry: {
        page1: "./page1",
        page2: "./page2"
    }
}
</code></pre>
<p>当一个项目很庞大的时候，比如有上百个 entry，如果我们只是要改其中一个页面，但是却要把全部 entry 都打包，势必速度就会大大降低。
所以会先让用户选择某一个，然后让 webpack 只打包这个 entry。</p>
<p>这也带来另外一个问题，如果我们要改另外的页面，就得结束当前的程序，重新运行命令选择 entry。</p>
<h2 id="nextjs">next.js</h2>
<p>前几天把博客用 <code>next.js</code> 生成，发现 <code>next.js</code> 是根据路由去动态加载 entry。也就是当你访问某个页面，如果这个 entry 之前已经编译过，就直接返回。没有的话，就把这个页面加进去让 webpack 重新编译。这种方式就很好地解决了上面说的问题。 那 <code>next.js</code> 里面是怎样实现的呢？如果你也跑过 demo，应该能在终端看到类似下面的提示</p>
<pre><code>&gt; Building page: xxx
</code></pre>
<p>在源码里面搜下，可以很快的定位到 <a href="https://github.com/zeit/next.js/blob/3.2.1/server/on-demand-entry-handler.js#L151">on-demand-entry-handler.js</a> 里面的 <code>ensurePage</code></p>
<pre><code class="js language-js">{
    async ensurePage (page) {
      await this.waitUntilReloaded()
      page = normalizePage(page)

      const pagePath = join(dir, 'pages', page)
      const pathname = await resolvePath(pagePath)
      const name = join('bundles', pathname.substring(dir.length))

      const entry = [`${pathname}?entry`]

      await new Promise((resolve, reject) =&gt; {
        const entryInfo = entries[page]

        if (entryInfo) {
          if (entryInfo.status === BUILT) {
            resolve()
            return
          }

          if (entryInfo.status === BUILDING) {
            doneCallbacks.on(page, processCallback)
            return
          }
        }

        console.log(`&gt; Building page: ${page}`)

        entries[page] = { name, entry, pathname, status: ADDED }
        doneCallbacks.on(page, processCallback)

        invalidator.invalidate()

        function processCallback (err) {
          if (err) return reject(err)
          resolve()
        }
      })
    }
}
</code></pre>
<p>参数 <code>page</code> 是当前访问的路径，先从 <code>entries</code> 取对应的 <code>entryInfo</code></p>
<pre><code class="js language-js">if (entryInfo) {
    if (entryInfo.status === BUILT) {
        resolve()
        return
    }

    if (entryInfo.status === BUILDING) {
        doneCallbacks.on(page, processCallback)
        return
    }
}
</code></pre>
<p>如果存在的话，判断下这个 <code>entryInfo</code> 的状态。如果是已经编译过的，直接返回。如果是正在编译，则监听以这个页面为名字的事件。这里猜想当编译完之后，就会触发对应的事件。这里的 <code>doneCallbacks</code> 是一个 <code>EventEmitter</code> 实例。</p>
<pre><code class="js language-js">import { EventEmitter } from 'events'

let doneCallbacks = new EventEmitter()
</code></pre>
<p>如果不存在这个 entry 的话，打印提示，初始化 entry，加到 <code>entries</code> 当中。同样的也要监听这个页面事件。</p>
<pre><code class="js language-js">console.log(`&gt; Building page: ${page}`)

entries[page] = { name, entry, pathname, status: ADDED }
doneCallbacks.on(page, processCallback)

invalidator.invalidate()
</code></pre>
<p>最后面一句的作用是让 webpack 重新编译，<code>invalidator</code> 是 <code>Invalidator</code> 实例，用于维护 webpack 打包时候的状态。</p>
<pre><code class="js language-js">class Invalidator {
  constructor (devMiddleware) {
    this.devMiddleware = devMiddleware
    this.building = false
    this.rebuildAgain = false
  }

  invalidate () {
    if (this.building) {
      this.rebuildAgain = true
      return
    }

    this.building = true
    this.devMiddleware.invalidate()
  }

  startBuilding () {
    this.building = true
  }

  doneBuilding () {
    this.building = false
    if (this.rebuildAgain) {
      this.rebuildAgain = false
      this.invalidate()
    }
  }
}
</code></pre>
<p>这个类中初始化传入的 <code>devMiddleware</code> 就是我们平时用的 <a href="https://github.com/webpack/webpack-dev-middleware">webpack-dev-middleware</a>，项目的 <a href="https://github.com/webpack/webpack-dev-middleware#advanced-api">README</a> 也有对 <code>invalidate</code> 进行说明。上面我们只是把 entry 加到了 <code>entries</code> 里面，而 <code>entries</code> 只是一个很普通的全局对象，那 webpack 的配置是怎样被更改的呢？</p>
<p>在这个文件往上翻的话，可以看到初始化了下面这个插件</p>
<pre><code class="js language-js">compiler.plugin('make', function (compilation, done) {
    invalidator.startBuilding()

    const allEntries = Object.keys(entries).map((page) =&gt; {
        const { name, entry } = entries[page]
        entries[page].status = BUILDING
        return addEntry(compilation, this.context, name, entry)
    })

    Promise.all(allEntries)
        .then(() =&gt; done())
        .catch(done)
})
</code></pre>
<p>写过 webpack 插件的应该对上面的代码很熟悉了，这里调用了 <code>invalidator.startBuilding</code>，保证 webpack 只有在编译完成后才能再次编译。然后遍历 <code>entries</code> 这个全局对象，给每个 entry 调用 <code>addEntry</code> 这个方法。</p>
<pre><code class="js language-js">import DynamicEntryPlugin from 'webpack/lib/DynamicEntryPlugin'

function addEntry (compilation, context, name, entry) {
  return new Promise((resolve, reject) =&gt; {
    const dep = DynamicEntryPlugin.createDependency(entry, name)
    compilation.addEntry(context, dep, name, (err) =&gt; {
      if (err) return reject(err)
      resolve()
    })
  })
}
</code></pre>
<p><code>addEntry</code> 返回一个 <code>Promise</code>，调用 webpack 内置的 <code>DynamicEntryPlugin</code> 插件创建真正的 entry，并加入到 <code>compilation</code> 中。到此，你新加入的 <code>entry</code> 就会被编译了。那编译成功之后呢，我们还监听了对应页面的事件。</p>
<p>这里面其实还初始化了另外一个插件</p>
<pre><code class="js language-js">compiler.plugin('done', function (stats) {
    // Call all the doneCallbacks
    Object.keys(entries).forEach((page) =&gt; {
      const entryInfo = entries[page]
      if (entryInfo.status !== BUILDING) return

      entryInfo.status = BUILT
      entries[page].lastActiveTime = Date.now()
      doneCallbacks.emit(page)
    })

    invalidator.doneBuilding()
})
</code></pre>
<p>源码里面还做了一些错误处理，这里只看我们关心的部分。在 webpack 编译完成后，先遍历 <code>entries</code>，找到其中状态为 <code>BUILDING</code> 的 entry，把状态改为 <code>BUILT</code>，然后触发对应的事件，<code>doneCallbacks.emit(page)</code>，这样之前监听在这个页面的回调函数就被会被触发。</p>
<p>完成上面的事情之后，还调用了 <code>doneBuilding</code>。这个其实是检查一下在刚刚 webpack 的编译过程中，有没有新的 entry 要求被重新编译，有的话，再次调用 <code>invalidate</code>，让 webpack 再编译一次。</p>
<h2 id="">后记</h2>
<p>在实际的项目当中，可以把上面的处理过程封装成一个 express 的中间件，这样子我们平时开发只要运行一下 <code>make dev</code>，启动一下服务器，然后根据访问的路由去编译对应的 entry 就可以。</p>
<p>最后，还剩下一个问题。一开始的 entry 要初始化成什么呢，如果 webpack 接受到的是一个空的 entry，会直接抛出错误。我的做法是随机选一个 entry 初始化，如果第一次访问到这个随机 entry，还可以加多一个彩蛋效果。比如在终端输出</p>
<pre><code>Boom!!! You have hit the random entry.
</code></pre>
<p>(完)</p></div><div class="sc-jTzLTM frgWBf">2017.09.06</div></div><div class="sc-fjdhpX OaFaI" id="disqus_thread"></div></div></div><div class="sc-htoDjs hBdBXi"><span class="sc-dnqmqq gQextd">Powered by <a href="https://github.com/clinyong/cubi">Cubi</a>,  </span><span class="sc-dnqmqq gQextd">Hosted by <a href="https://pages.coding.me">Coding Pages</a></span></div></div></div>
    
      <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
              navigator.serviceWorker.register('/sw.js');
            });
          }
      </script>
      
    <script>
		
    </script>
    <script>
		var INIT_PROPS = {"content":{"meta":{"title":"动态加载 webpack entry","date":"2017.09.06"},"content":"\n在多页面的项目中，一般我们会把每个页面作为一个 webpack 的 entry，比如像下面这样的配置文件\n\n```js\nmodule.exports = {\n    entry: {\n        page1: \"./page1\",\n        page2: \"./page2\"\n    }\n}\n```\n\n当一个项目很庞大的时候，比如有上百个 entry，如果我们只是要改其中一个页面，但是却要把全部 entry 都打包，势必速度就会大大降低。\n所以会先让用户选择某一个，然后让 webpack 只打包这个 entry。\n\n这也带来另外一个问题，如果我们要改另外的页面，就得结束当前的程序，重新运行命令选择 entry。\n\n## next.js\n\n前几天把博客用 `next.js` 生成，发现 `next.js` 是根据路由去动态加载 entry。也就是当你访问某个页面，如果这个 entry 之前已经编译过，就直接返回。没有的话，就把这个页面加进去让 webpack 重新编译。这种方式就很好地解决了上面说的问题。 那 `next.js` 里面是怎样实现的呢？如果你也跑过 demo，应该能在终端看到类似下面的提示\n\n```\n&gt; Building page: xxx\n```\n\n在源码里面搜下，可以很快的定位到 [on-demand-entry-handler.js](https://github.com/zeit/next.js/blob/3.2.1/server/on-demand-entry-handler.js#L151) 里面的 `ensurePage`\n\n```js\n{\n    async ensurePage (page) {\n      await this.waitUntilReloaded()\n      page = normalizePage(page)\n\n      const pagePath = join(dir, 'pages', page)\n      const pathname = await resolvePath(pagePath)\n      const name = join('bundles', pathname.substring(dir.length))\n\n      const entry = [`${pathname}?entry`]\n\n      await new Promise((resolve, reject) => {\n        const entryInfo = entries[page]\n\n        if (entryInfo) {\n          if (entryInfo.status === BUILT) {\n            resolve()\n            return\n          }\n\n          if (entryInfo.status === BUILDING) {\n            doneCallbacks.on(page, processCallback)\n            return\n          }\n        }\n\n        console.log(`> Building page: ${page}`)\n\n        entries[page] = { name, entry, pathname, status: ADDED }\n        doneCallbacks.on(page, processCallback)\n\n        invalidator.invalidate()\n\n        function processCallback (err) {\n          if (err) return reject(err)\n          resolve()\n        }\n      })\n    }\n}\n```\n\n参数 `page` 是当前访问的路径，先从 `entries` 取对应的 `entryInfo`\n\n```js\nif (entryInfo) {\n    if (entryInfo.status === BUILT) {\n        resolve()\n        return\n    }\n\n    if (entryInfo.status === BUILDING) {\n        doneCallbacks.on(page, processCallback)\n        return\n    }\n}\n```\n\n如果存在的话，判断下这个 `entryInfo` 的状态。如果是已经编译过的，直接返回。如果是正在编译，则监听以这个页面为名字的事件。这里猜想当编译完之后，就会触发对应的事件。这里的 `doneCallbacks` 是一个 `EventEmitter` 实例。\n\n```js\nimport { EventEmitter } from 'events'\n\nlet doneCallbacks = new EventEmitter()\n```\n\n如果不存在这个 entry 的话，打印提示，初始化 entry，加到 `entries` 当中。同样的也要监听这个页面事件。\n\n```js\nconsole.log(`> Building page: ${page}`)\n\nentries[page] = { name, entry, pathname, status: ADDED }\ndoneCallbacks.on(page, processCallback)\n\ninvalidator.invalidate()\n```\n\n最后面一句的作用是让 webpack 重新编译，`invalidator` 是 `Invalidator` 实例，用于维护 webpack 打包时候的状态。\n\n```js\nclass Invalidator {\n  constructor (devMiddleware) {\n    this.devMiddleware = devMiddleware\n    this.building = false\n    this.rebuildAgain = false\n  }\n\n  invalidate () {\n    if (this.building) {\n      this.rebuildAgain = true\n      return\n    }\n\n    this.building = true\n    this.devMiddleware.invalidate()\n  }\n\n  startBuilding () {\n    this.building = true\n  }\n\n  doneBuilding () {\n    this.building = false\n    if (this.rebuildAgain) {\n      this.rebuildAgain = false\n      this.invalidate()\n    }\n  }\n}\n```\n\n这个类中初始化传入的 `devMiddleware` 就是我们平时用的 [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware)，项目的 [README](https://github.com/webpack/webpack-dev-middleware#advanced-api) 也有对 `invalidate` 进行说明。上面我们只是把 entry 加到了 `entries` 里面，而 `entries` 只是一个很普通的全局对象，那 webpack 的配置是怎样被更改的呢？\n\n在这个文件往上翻的话，可以看到初始化了下面这个插件\n\n```js\ncompiler.plugin('make', function (compilation, done) {\n    invalidator.startBuilding()\n\n    const allEntries = Object.keys(entries).map((page) => {\n        const { name, entry } = entries[page]\n        entries[page].status = BUILDING\n        return addEntry(compilation, this.context, name, entry)\n    })\n\n    Promise.all(allEntries)\n        .then(() => done())\n        .catch(done)\n})\n```\n\n写过 webpack 插件的应该对上面的代码很熟悉了，这里调用了 `invalidator.startBuilding`，保证 webpack 只有在编译完成后才能再次编译。然后遍历 `entries` 这个全局对象，给每个 entry 调用 `addEntry` 这个方法。\n\n```js\nimport DynamicEntryPlugin from 'webpack/lib/DynamicEntryPlugin'\n\nfunction addEntry (compilation, context, name, entry) {\n  return new Promise((resolve, reject) => {\n    const dep = DynamicEntryPlugin.createDependency(entry, name)\n    compilation.addEntry(context, dep, name, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n```\n\n`addEntry` 返回一个 `Promise`，调用 webpack 内置的 `DynamicEntryPlugin` 插件创建真正的 entry，并加入到 `compilation` 中。到此，你新加入的 `entry` 就会被编译了。那编译成功之后呢，我们还监听了对应页面的事件。\n\n这里面其实还初始化了另外一个插件\n\n```js\ncompiler.plugin('done', function (stats) {\n    // Call all the doneCallbacks\n    Object.keys(entries).forEach((page) => {\n      const entryInfo = entries[page]\n      if (entryInfo.status !== BUILDING) return\n\n      entryInfo.status = BUILT\n      entries[page].lastActiveTime = Date.now()\n      doneCallbacks.emit(page)\n    })\n\n    invalidator.doneBuilding()\n})\n```\n\n源码里面还做了一些错误处理，这里只看我们关心的部分。在 webpack 编译完成后，先遍历 `entries`，找到其中状态为 `BUILDING` 的 entry，把状态改为 `BUILT`，然后触发对应的事件，`doneCallbacks.emit(page)`，这样之前监听在这个页面的回调函数就被会被触发。\n\n完成上面的事情之后，还调用了 `doneBuilding`。这个其实是检查一下在刚刚 webpack 的编译过程中，有没有新的 entry 要求被重新编译，有的话，再次调用 `invalidate`，让 webpack 再编译一次。\n\n## 后记\n\n在实际的项目当中，可以把上面的处理过程封装成一个 express 的中间件，这样子我们平时开发只要运行一下 `make dev`，启动一下服务器，然后根据访问的路由去编译对应的 entry 就可以。\n\n最后，还剩下一个问题。一开始的 entry 要初始化成什么呢，如果 webpack 接受到的是一个空的 entry，会直接抛出错误。我的做法是随机选一个 entry 初始化，如果第一次访问到这个随机 entry，还可以加多一个彩蛋效果。比如在终端输出\n\n```\nBoom!!! You have hit the random entry.\n```\n\n(完)\n"}};
    </script>
    
    <script src=/js/vendors.094c268b.dll.js></script>
    
    <script src=/js/__post.a85ba19a.dll.js></script>
    
    <script src=/js/post.cb81a6af.js></script>
    
</body>

</html>
