<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    
      <title>
        React 长列表问题 | Leodots
      </title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style type="text/css" data-styled-components="djiuUw ehFhRk bjznky ehsBOr cKUUOL bUfeR dQozFt bxrUCS hBdBXi gQextd" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {}

.djiuUw{display:block;text-align:center;padding:0;margin:0;padding-top:30px;list-style:none;height:55px;margin-left:calc(100vw - 100%);}@media screen and (max-width:770px){.djiuUw{display:none;}}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {}

.ehFhRk{text-align:center;font-size:18px;margin:0 25px;display:inline-block;}.ehFhRk:hover{border-bottom:2px solid #222;}.ehFhRk > a{-webkit-text-decoration:none;text-decoration:none;color:#222;}
/* sc-component-id: sc-htpNat */
.sc-htpNat {}

.bjznky{position:relative;}@media screen and (min-width:770px){.bjznky{display:none;}}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {}

.ehsBOr{text-align:center;background-color:#464d5c;color:#fff;padding:40px 10px;font-size:40px;}
/* sc-component-id: sc-ifAKCX */
.sc-ifAKCX {}

.cKUUOL{color:#bee178;}
/* sc-component-id: sc-EHOje */
.sc-EHOje {}

.bUfeR{position:absolute;right:0px;padding:19px 19px;top:0px;border-radius:50%;background-color:transparent;border-color:transparent;-webkit-transition:0.5s background-color;transition:0.5s background-color;}
/* sc-component-id: sc-bZQynM */
.sc-bZQynM {}

.dQozFt{height:2px;width:18px;margin-bottom:3px;display:block;background-color:#bee178;}
/* sc-component-id: sc-gzVnrw */
.sc-gzVnrw {}

.bxrUCS{position:absolute;right:20px;top:42px;width:150px;height:125px;background-color:#fff;box-shadow:rgba(0,0,0,0.117647) 0 1px 6px, rgba(0,0,0,0.239216) 0 1px 4px;-webkit-transition:0.2s;transition:0.2s;overflow:hidden;padding:10px 0;}.bxrUCS > li{list-style:none;}.bxrUCS > li > a{-webkit-text-decoration:none;text-decoration:none;color:#777;display:block;padding:10px 20px;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {}

.hBdBXi{position:absolute;bottom:20px;left:0;right:0;text-align:center;font-size:12px;}
/* sc-component-id: sc-dnqmqq */
.sc-dnqmqq {}

.gQextd{color:#999;}.gQextd > a{color:#bee178 !important;-webkit-text-decoration:none;text-decoration:none;}@media screen and (min-width:770px){.gQextd > a{color:#108ee9 !important;-webkit-text-decoration:underline;text-decoration:underline;}}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1576189413 */
html{position:relative;background-color:#464d5c;font-family:'PingFang SC','Hiragino Sans GB','Microsoft Yahei','WenQuanYi Micro Hei',sans-serif;}@media screen and (min-width:770px){html{background-color:#ECF0F1;}}html,body{min-height:100vh;margin:0;padding:0;}#app{min-height:100vh;}
</style><style type="text/css" data-styled-components="gkwKrD gIWTme iLKjzi fCjyQ kqQANZ frgWBf OaFaI" data-styled-components-is-local="true">/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {}

.gkwKrD{position:relative;min-height:100vh;}
/* sc-component-id: sc-gZMcBi */
.sc-gZMcBi {}

.gIWTme{padding-bottom:60px;}@media screen and (min-width:770px){.gIWTme{padding:0px 0 100px;margin-left:calc(100vw - 100%);}}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {}

.iLKjzi{padding:20px 15px 25px;background-color:#fff;}@media screen and (min-width:770px){.iLKjzi{box-sizing:border-box;width:768px;margin:0 auto;padding-left:40px;padding-right:40px;box-shadow:0px 30px 60px 0px #d3dde2;}}
/* sc-component-id: sc-VigVT */
.sc-VigVT {}

.kqQANZ{margin-top:0;margin-bottom:30px;text-align:center;font-size:24px;}@media screen and (min-width:770px){.kqQANZ{font-size:30px;}}
/* sc-component-id: sc-jTzLTM */
.sc-jTzLTM {}

.frgWBf{text-align:center;color:#999;margin-top:50px;font-size:12px;-webkit-text-decoration:underline;text-decoration:underline;}
/* sc-component-id: sc-fjdhpX */
.sc-fjdhpX {}

.OaFaI{background-color:#fff;padding-top:60px;}
/* sc-component-id: sc-jzJRlG */
.sc-jzJRlG {}

.fCjyQ{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.fCjyQ{min-height:500px;}.fCjyQ a:hover{-webkit-text-decoration:underline;text-decoration:underline;cursor:pointer;}}.fCjyQ a{color:#3194d0;}.fCjyQ p,.fCjyQ li{line-height:1.8;}.fCjyQ img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.fCjyQ img{max-width:500px;}}.fCjyQ code{background:#f2f2f2;padding:2px 5px;}.fCjyQ pre{background:#f2f2f2;padding:20px;overflow-x:auto;line-height:1.8;}.fCjyQ pre > code{padding:0;}.fCjyQ blockquote{margin-left:0;padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}
</style>
</head>

<body>
    <div id="app"><div class="sc-iwsKbI gkwKrD" data-reactroot=""><div><ul class="sc-bdVaJa djiuUw"><li class="sc-bwzfXH ehFhRk"><a href="/">首页</a></li><li class="sc-bwzfXH ehFhRk"><a href="/archive.html">归档</a></li><li class="sc-bwzfXH ehFhRk"><a href="/about.html">关于</a></li></ul><div class="sc-htpNat bjznky"><div class="sc-bxivhb ehsBOr"><span class="sc-ifAKCX cKUUOL">&lt;Leodots /&gt;</span></div><button class="sc-EHOje bUfeR"><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span></button><ul class="sc-gzVnrw bxrUCS" style="width:0;height:0"><li><a href="/">首页</a></li><li><a href="/archive.html">归档</a></li><li><a href="/about.html">关于</a></li></ul></div></div><div class="sc-gZMcBi gIWTme"><div class="sc-gqjmRU iLKjzi"><div class="sc-jzJRlG fCjyQ"><div class="sc-VigVT kqQANZ">React 长列表问题</div><div class="sc-jzJRlG fCjyQ"><p>在使用 antd 的 <a href="https://ant.design/components/select-cn/">select</a> 组件的时候，当选项超过了一定数量，比如有 10000 个选项，这时候组件不管是点击弹出或者滚动都会特别的卡。当然这不是 antd 或者 React 的问题，而是前端开发里面比较常见的长列表问题。实际上并没有必要一次性把 10000 个选项都渲染出来，只需要渲染可视区域内的元素就行，这样明显数量要少得多。</p>
<p>React 社区这边比较知名的就是 <a href="https://github.com/bvaughn/react-virtualized">react-virtualized</a>，我也是参考了这个库，写了一个简单够用的版本，<a href="https://github.com/clinyong/react-scroll-list">react-scroll-list</a>。以及一个基于这个库的 select 组件，<a href="https://github.com/clinyong/react-large-select">react-large-select</a>。</p>
<p>下面简单说下 <code>react-scroll-list</code> 的实现。首先看下这个组件接受的属性</p>
<pre><code class="ts language-ts">export interface RowRendererParams {
    index: number;
    style: React.CSSProperties;
}

export interface ScrollListProps {
    height: number;
    rowHeight: number;
    total: number;
    rowRenderer: (params: RowRendererParams) =&gt; any;
}
</code></pre>
<p><code>height</code> 是可视区域的高度，<code>rowHeight</code> 是每一行的高度，<code>total</code> 是总的有多少行，<code>rowRenderer</code> 是每一行要怎样渲染。看下 <code>render</code> 方法</p>
<pre><code class="tsx language-tsx">render() {
    const { height, total, rowHeight } = this.props;
    return (
        &lt;div
            style={{
                overflowX: "hidden",
                overflowY: "auto",
                height
            }}
            onScroll={this.onScroll}
            ref={container =&gt; (this.scrollingContainer = container)}
        &gt;
            &lt;div
                style={{
                    height: total * rowHeight,
                    position: "relative"
                }}
            &gt;
                {this.renderDisplayContent()}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
</code></pre>
<p>最外层的 <code>div</code> 为可视区域，并且设置超过的时候显示滚动条。里面的 <code>div</code> 设置完整的高度，也就是每一行的高度乘以总的行数。然后监听最外层的滚动事件。</p>
<pre><code class="ts language-ts">onScroll = (e: React.UIEvent&lt;any&gt;) =&gt; {
    if (e.target === this.scrollingContainer) {
        const { scrollTop } = e.target as any;

        this.setState({
            scrollTop
        });
    }
};
</code></pre>
<p>每次滚动的时候，更新一下 scrollTop，触发 render。这里可以对 <code>onScroll</code> 做下限流。</p>
<pre><code class="ts language-ts">get limit() {
    const { rowHeight, height } = this.props;
    return Math.ceil(height / rowHeight);
}

renderDisplayContent = () =&gt; {
    const { scrollTop } = this.state;
    const { rowHeight, rowRenderer, total } = this.props;

    const startIndex = Math.floor(scrollTop / rowHeight);
    const endIndex = Math.min(startIndex + this.limit, total - 1);

    let content = [];
    for (let i = startIndex; i &lt;= endIndex; i++) {
        content.push(
            rowRenderer({
                index: i,
                style: {
                    height: rowHeight,
                    left: 0,
                    right: 0,
                    position: "absolute",
                    top: i * rowHeight
                }
            })
        );
    }

    return content;
};
</code></pre>
<p>最后是最核心的方法，<code>renderDisplayContent</code>，决定着可视区域里面显示哪些子元素。通过 <code>scrollTop</code> 我们可以知道应该从第几个子元素开始渲染，
然后通过 <code>height</code> 和 <code>rowHeight</code> 算出可视化区域可以显示的子元素个数，最终就可以知道结束的索引。然后调用 <code>rowRenderer</code> 方法，获得完整的显示列表。</p>
<p>（完）</p></div><div class="sc-jTzLTM frgWBf">2018.07.16</div></div><div class="sc-fjdhpX OaFaI" id="disqus_thread"></div></div></div><div class="sc-htoDjs hBdBXi"><span class="sc-dnqmqq gQextd">Powered by <a href="https://github.com/clinyong/cubi">Cubi</a>,  </span><span class="sc-dnqmqq gQextd">Hosted by <a href="https://pages.coding.me">Coding Pages</a></span></div></div></div>
    
      <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
              navigator.serviceWorker.register('/sw.js');
            });
          }
      </script>
      
    <script>
		
    </script>
    <script>
		var INIT_PROPS = {"content":{"meta":{"title":"React 长列表问题","date":"2018.07.16"},"content":"\n在使用 antd 的 [select](https://ant.design/components/select-cn/) 组件的时候，当选项超过了一定数量，比如有 10000 个选项，这时候组件不管是点击弹出或者滚动都会特别的卡。当然这不是 antd 或者 React 的问题，而是前端开发里面比较常见的长列表问题。实际上并没有必要一次性把 10000 个选项都渲染出来，只需要渲染可视区域内的元素就行，这样明显数量要少得多。\n\nReact 社区这边比较知名的就是 [react-virtualized](https://github.com/bvaughn/react-virtualized)，我也是参考了这个库，写了一个简单够用的版本，[react-scroll-list](https://github.com/clinyong/react-scroll-list)。以及一个基于这个库的 select 组件，[react-large-select](https://github.com/clinyong/react-large-select)。\n\n下面简单说下 `react-scroll-list` 的实现。首先看下这个组件接受的属性\n\n```ts\nexport interface RowRendererParams {\n\tindex: number;\n\tstyle: React.CSSProperties;\n}\n\nexport interface ScrollListProps {\n\theight: number;\n\trowHeight: number;\n\ttotal: number;\n\trowRenderer: (params: RowRendererParams) =&gt; any;\n}\n```\n\n`height` 是可视区域的高度，`rowHeight` 是每一行的高度，`total` 是总的有多少行，`rowRenderer` 是每一行要怎样渲染。看下 `render` 方法\n\n```tsx\nrender() {\n    const { height, total, rowHeight } = this.props;\n    return (\n        &lt;div\n            style={{\n                overflowX: \"hidden\",\n                overflowY: \"auto\",\n                height\n            }}\n            onScroll={this.onScroll}\n            ref={container => (this.scrollingContainer = container)}\n        >\n            &lt;div\n                style={{\n                    height: total * rowHeight,\n                    position: \"relative\"\n                }}\n            >\n                {this.renderDisplayContent()}\n            &lt;/div>\n        &lt;/div>\n    );\n}\n```\n\n最外层的 `div` 为可视区域，并且设置超过的时候显示滚动条。里面的 `div` 设置完整的高度，也就是每一行的高度乘以总的行数。然后监听最外层的滚动事件。\n\n```ts\nonScroll = (e: React.UIEvent&lt;any>) => {\n    if (e.target === this.scrollingContainer) {\n        const { scrollTop } = e.target as any;\n\n        this.setState({\n            scrollTop\n        });\n    }\n};\n```\n\n每次滚动的时候，更新一下 scrollTop，触发 render。这里可以对 `onScroll` 做下限流。\n\n```ts\nget limit() {\n    const { rowHeight, height } = this.props;\n    return Math.ceil(height / rowHeight);\n}\n\nrenderDisplayContent = () => {\n    const { scrollTop } = this.state;\n    const { rowHeight, rowRenderer, total } = this.props;\n\n    const startIndex = Math.floor(scrollTop / rowHeight);\n    const endIndex = Math.min(startIndex + this.limit, total - 1);\n\n    let content = [];\n    for (let i = startIndex; i &lt;= endIndex; i++) {\n        content.push(\n            rowRenderer({\n                index: i,\n                style: {\n                    height: rowHeight,\n                    left: 0,\n                    right: 0,\n                    position: \"absolute\",\n                    top: i * rowHeight\n                }\n            })\n        );\n    }\n\n    return content;\n};\n```\n\n最后是最核心的方法，`renderDisplayContent`，决定着可视区域里面显示哪些子元素。通过 `scrollTop` 我们可以知道应该从第几个子元素开始渲染，\n然后通过 `height` 和 `rowHeight` 算出可视化区域可以显示的子元素个数，最终就可以知道结束的索引。然后调用 `rowRenderer` 方法，获得完整的显示列表。\n\n（完）\n"}};
    </script>
    
    <script src=/js/vendors.094c268b.dll.js></script>
    
    <script src=/js/__post.a85ba19a.dll.js></script>
    
    <script src=/js/post.cb81a6af.js></script>
    
</body>

</html>
