<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    
      <title>
        Cubi 的由来 | Leodots
      </title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style type="text/css" data-styled-components="djiuUw ehFhRk bjznky ehsBOr cKUUOL bUfeR dQozFt bxrUCS hBdBXi gQextd" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {}

.djiuUw{display:block;text-align:center;padding:0;margin:0;padding-top:30px;list-style:none;height:55px;margin-left:calc(100vw - 100%);}@media screen and (max-width:770px){.djiuUw{display:none;}}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {}

.ehFhRk{text-align:center;font-size:18px;margin:0 25px;display:inline-block;}.ehFhRk:hover{border-bottom:2px solid #222;}.ehFhRk > a{-webkit-text-decoration:none;text-decoration:none;color:#222;}
/* sc-component-id: sc-htpNat */
.sc-htpNat {}

.bjznky{position:relative;}@media screen and (min-width:770px){.bjznky{display:none;}}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {}

.ehsBOr{text-align:center;background-color:#464d5c;color:#fff;padding:40px 10px;font-size:40px;}
/* sc-component-id: sc-ifAKCX */
.sc-ifAKCX {}

.cKUUOL{color:#bee178;}
/* sc-component-id: sc-EHOje */
.sc-EHOje {}

.bUfeR{position:absolute;right:0px;padding:19px 19px;top:0px;border-radius:50%;background-color:transparent;border-color:transparent;-webkit-transition:0.5s background-color;transition:0.5s background-color;}
/* sc-component-id: sc-bZQynM */
.sc-bZQynM {}

.dQozFt{height:2px;width:18px;margin-bottom:3px;display:block;background-color:#bee178;}
/* sc-component-id: sc-gzVnrw */
.sc-gzVnrw {}

.bxrUCS{position:absolute;right:20px;top:42px;width:150px;height:125px;background-color:#fff;box-shadow:rgba(0,0,0,0.117647) 0 1px 6px, rgba(0,0,0,0.239216) 0 1px 4px;-webkit-transition:0.2s;transition:0.2s;overflow:hidden;padding:10px 0;}.bxrUCS > li{list-style:none;}.bxrUCS > li > a{-webkit-text-decoration:none;text-decoration:none;color:#777;display:block;padding:10px 20px;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {}

.hBdBXi{position:absolute;bottom:20px;left:0;right:0;text-align:center;font-size:12px;}
/* sc-component-id: sc-dnqmqq */
.sc-dnqmqq {}

.gQextd{color:#999;}.gQextd > a{color:#bee178 !important;-webkit-text-decoration:none;text-decoration:none;}@media screen and (min-width:770px){.gQextd > a{color:#108ee9 !important;-webkit-text-decoration:underline;text-decoration:underline;}}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1576189413 */
html{position:relative;background-color:#464d5c;font-family:'PingFang SC','Hiragino Sans GB','Microsoft Yahei','WenQuanYi Micro Hei',sans-serif;}@media screen and (min-width:770px){html{background-color:#ECF0F1;}}html,body{min-height:100vh;margin:0;padding:0;}#app{min-height:100vh;}
</style><style type="text/css" data-styled-components="gkwKrD gIWTme iLKjzi fCjyQ kqQANZ frgWBf OaFaI" data-styled-components-is-local="true">/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {}

.gkwKrD{position:relative;min-height:100vh;}
/* sc-component-id: sc-gZMcBi */
.sc-gZMcBi {}

.gIWTme{padding-bottom:60px;}@media screen and (min-width:770px){.gIWTme{padding:0px 0 100px;margin-left:calc(100vw - 100%);}}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {}

.iLKjzi{padding:20px 15px 25px;background-color:#fff;}@media screen and (min-width:770px){.iLKjzi{box-sizing:border-box;width:768px;margin:0 auto;padding-left:40px;padding-right:40px;box-shadow:0px 30px 60px 0px #d3dde2;}}
/* sc-component-id: sc-VigVT */
.sc-VigVT {}

.kqQANZ{margin-top:0;margin-bottom:30px;text-align:center;font-size:24px;}@media screen and (min-width:770px){.kqQANZ{font-size:30px;}}
/* sc-component-id: sc-jTzLTM */
.sc-jTzLTM {}

.frgWBf{text-align:center;color:#999;margin-top:50px;font-size:12px;-webkit-text-decoration:underline;text-decoration:underline;}
/* sc-component-id: sc-fjdhpX */
.sc-fjdhpX {}

.OaFaI{background-color:#fff;padding-top:60px;}
/* sc-component-id: sc-jzJRlG */
.sc-jzJRlG {}

.fCjyQ{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.fCjyQ{min-height:500px;}.fCjyQ a:hover{-webkit-text-decoration:underline;text-decoration:underline;cursor:pointer;}}.fCjyQ a{color:#3194d0;}.fCjyQ p,.fCjyQ li{line-height:1.8;}.fCjyQ img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.fCjyQ img{max-width:500px;}}.fCjyQ code{background:#f2f2f2;padding:2px 5px;}.fCjyQ pre{background:#f2f2f2;padding:20px;overflow-x:auto;line-height:1.8;}.fCjyQ pre > code{padding:0;}.fCjyQ blockquote{margin-left:0;padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}
</style>
</head>

<body>
    <div id="app"><div class="sc-iwsKbI gkwKrD" data-reactroot=""><div><ul class="sc-bdVaJa djiuUw"><li class="sc-bwzfXH ehFhRk"><a href="/">首页</a></li><li class="sc-bwzfXH ehFhRk"><a href="/archive.html">归档</a></li><li class="sc-bwzfXH ehFhRk"><a href="/about.html">关于</a></li></ul><div class="sc-htpNat bjznky"><div class="sc-bxivhb ehsBOr"><span class="sc-ifAKCX cKUUOL">&lt;Leodots /&gt;</span></div><button class="sc-EHOje bUfeR"><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span></button><ul class="sc-gzVnrw bxrUCS" style="width:0;height:0"><li><a href="/">首页</a></li><li><a href="/archive.html">归档</a></li><li><a href="/about.html">关于</a></li></ul></div></div><div class="sc-gZMcBi gIWTme"><div class="sc-gqjmRU iLKjzi"><div class="sc-jzJRlG fCjyQ"><div class="sc-VigVT kqQANZ">Cubi 的由来</div><div class="sc-jzJRlG fCjyQ"><p>博客建立到现在一年多，已经重构了两次，之前也写了两篇文章简单地介绍博客的构建过程</p>
<ul>
<li><a href="https://blog.leodots.me/post/1-hello-world.html">Hello World</a></li>
<li><a href="https://blog.leodots.me/post/7-nextjs-static.html">用 next.js 构建博客</a></li>
</ul>
<p>在第二篇文章的末尾也提到，用 <code>next.js</code> 包含了很多功能，生成出来的静态文件也复杂得多。最直观的感受就是，用 <code>next.js</code> 构建完之后，用 <a href="https://developers.google.com/speed/pagespeed/insights/?hl=zh-CN">PageSpeed</a> 测试出来的得分反而降低了。</p>
<p>而用 <code>next.js</code> 的目的就是为了能用 React 来写博客页面，并且第一次加载的时候能有内容（其实就是 React 的服务器端渲染）。考虑清楚之后，觉得难度不大，加上想自己造造轮子，便写了 <a href="https://github.com/clinyong/cubi">Cubi</a>，一个用 React 生成静态博客的工具。这个名字的由来，也是取自火影当中九尾的谐音。</p>
<p><img src="http://g.udn.com.tw/upfiles/B_ME/meatball2/PSN_PHOTO/615/f_17000615_1.JPG" alt="" /></p>
<p>写这个工具，主要碰到了两个问题</p>
<ul>
<li>怎样静态输出 React 组件</li>
<li>怎样处理样式</li>
<li>怎样处理路由</li>
</ul>
<h3 id="react">静态输出 React 组件</h3>
<p><code>react-dom</code> 这个包提供了一个 <code>renderToString</code> 的方法，可以把组件以字符串的形式输出</p>
<pre><code class="ts language-ts">import * as ReactDOMServer from "react-dom/server";
import Component from "...";

const ins = React.createElement(Component, props);
const componentStr = ReactDOMServer.renderToString(ins);

console.log(componentStr);
</code></pre>
<p>只需要把输出的字符串，插入到我们的 HTML 模板里面，就可以正常显示了。输出完之后，还有一个问题，就是上面绑定的事件都没有了。这是因为 <code>renderToString</code> 只是做静态输出，并不会把事件绑定上去。还好 ReactDOM 提供了另外一个方法，(hydrate)[https://reactjs.org/docs/react-dom.html#hydrate]，来做这件事情。</p>
<p><code>hydrate</code> 的用法基本和 <code>render</code> 一样，官方的文档已经说的很清楚了</p>
<blockquote>
  <p>Same as render(), but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup.</p>
</blockquote>
<p>博客总共有 3 个<a href="https://github.com/clinyong/blog/tree/master/src/view">入口文件</a>，Cubi 读取了这三个入口文件之后，会通过一个 <a href="https://github.com/clinyong/cubi/blob/master/src/ReactHydrate.ts">Hydrate</a> 的插件，在每个入口文件里面加多一句</p>
<pre><code class="ts language-ts">ReactDOM.funcName(&lt;componentName /&gt;, document.getElementById("app"));
</code></pre>
<p>这里的 <code>componentName</code> 就是每个入口文件 <code>export default</code> 对应的组件名称，<code>funcName</code> 有两种情况，在开发模式下为 <code>render</code>，在编译发布的时候，是 <code>hydrate</code>。</p>
<h3 id="">添加样式</h3>
<p>样式是采用 <code>styled-component</code>，这个库本身也是支持服务器端渲染，<a href="https://www.styled-components.com/docs/advanced#server-side-rendering">官方文档</a> 也有很好的说明。<code>styled-component</code> 提供了一个 <code>getStyleTags</code>的 api，可以把整个页面用到的类都提取出来</p>
<pre><code class="ts language-ts">import * as ReactDOMServer from "react-dom/server";
import Component from "...";
import { ServerStyleSheet } from "styled-components";

const ins = React.createElement(Component, props);
const sheet = new ServerStyleSheet();
ReactDOMServer.renderToString(sheet.collectStyles(ins));

initStyles = sheet.getStyleTags();
console.log(initStyles);
</code></pre>
<p><code>initStyles</code> 就是整个组件，包括其子组件对应的样式，我们只需要把这部分直接插入到 HTML 模板的 head 头部就可以了。</p>
<blockquote>
  <p>这里也比较偷懒，直接把 Cubi 和 <code>styled-component</code> 绑定在一起，使的要用 Cubi 去生成页面的话，样式一定采用 <code>styled-component</code>。更好的做法应该像
  <code>next.js</code> 那样，可以自由选择第三方样式库。</p>
</blockquote>
<h3 id="-1">路由处理</h3>
<p>路由处理是比较麻烦的事情，在这里也是借鉴了 <code>next.js</code> 的做法。在 Cubi 的<a href="https://github.com/clinyong/blog/blob/master/cubi.config.js">配置文件</a>里面，有个 <code>exportPathMap</code> 用于配置路由</p>
<pre><code class="js language-js">{
    async exportPathMap() {
        const files = await readArticles();
        const pages = files.reduce(
            (pages, file) =&gt;
                Object.assign({}, pages, {
                    [file.link]: {
                        page: "post",
                        query: { content: file.result }
                    }
                }),
            {}
        );

        return Object.assign({}, pages, {
            index: {
                page: "index",
                query: {
                    articles: files.slice(0, 10).map(item =&gt; ({
                        link: item.link + ".html",
                        title: item.title
                    }))
                }
            },
            archive: {
                page: "index",
                query: {
                    articles: files.map(item =&gt; ({
                        link: item.link + ".html",
                        title: item.title
                    }))
                }
            },
            about: {
                page: "about"
            }
        });
    }
}
</code></pre>
<p><code>readArticles</code> 是把某个目录下面的文章全部读出来，转成一个 <code>pages</code> 对象。这个对象的每个 key 值就是文章的路径，比如这篇文章就是 <code>post/15-intro-cubi</code>。每个 key 对应的字段又是一个对象，这个对象里面的 <code>page</code> 是指定要选用哪个模板组件，<code>query</code> 是组件一开始加载的参数。</p>
<p><code>pages</code> 包含了所有的文章页面，除此之外还要再加上首页，归档和关于页面。上面这些就是博客的全部路由。</p>
<p>Cubi 内部是通过一个 HTML <a href="https://github.com/clinyong/cubi/blob/master/src/HTMLPlugin.ts">插件</a>来处理路由的</p>
<pre><code class="ts language-ts">const routesMap = await exportPathMap();

Object.keys(routesMap).forEach(k =&gt; {
    const routeItem = routesMap[k];
    const entryItem = entry[routeItem.page] as string;

    if (entryItem) {
        const entryPath = findEntryPath(entryItem);
        const props = routeItem.query;

        if (entryPath) {
            let initContent = "";
            let initStyles = "";
            let initProps = props ? JSON.stringify(props) : "{}";
            let entryList = [routeItem.page + ".js"];
            if (isProd) {
                // 静态输出组件，拿到 initContent 和 initStyles
                const sheet = new ServerStyleSheet();
                const Component = require(entryPath).default;
                const ins = React.createElement(Component, props);
                initContent = ReactDOMServer.renderToString(
                    sheet.collectStyles(ins)
                );
                initStyles = sheet.getStyleTags();
            }
        }

        const content = ejs.render(templateContent, {
            initProps
            // 传进模板里面的各种参数
        });

        compilation.assets[`${k}.html`] = {
            source: () =&gt; content,
            size: () =&gt; content.length
        };
    }
});
</code></pre>
<p>这个插件会遍历整个路由对象，根据每个路由上面定义的 <code>page</code> 字段找到对应的模板组件路径 <code>entryPath</code>，然后就是之前说的，静态输出这个组件，拿到对应的内容和样式，插入到 ejs 的模板里面。然后再把模板生成的内容，添加到 webpack 输出的 <code>assets</code> 里面。</p>
<p>当在服务器端静态输出组件的时候，我们直接把 <code>initProps</code> 传给 <code>React.createElement</code>，让组件能正常输出。但是当页面加载完，我们调用 <code>ReactDOM.render</code> 或者 <code>ReactDOM.hydrate</code> 时，怎样把参数传给组件呢？这里会把要初始化的 props 传给 ejs 模板，<a href="https://github.com/clinyong/cubi/blob/master/config/template.html#L17">模板里面</a>会创建一个全局变量 <code>INIT_PROPS</code>，最上面介绍的 <a href="https://github.com/clinyong/cubi/blob/master/src/ReactHydrate.ts#L64">Hydrate</a> 插件会在创建组件的时候，去读取这个值，类似下面这样</p>
<pre><code class="tsx language-tsx">ReactDOM.hydrate(
    React.createElement(Post, INIT_PROPS),
    document.getElementById("app")
);
</code></pre>
<p>上面就是 Cubi 基本的构建过程，更详细的实现，可以看下项目的源码。</p></div><div class="sc-jTzLTM frgWBf">2018.03.31</div></div><div class="sc-fjdhpX OaFaI" id="disqus_thread"></div></div></div><div class="sc-htoDjs hBdBXi"><span class="sc-dnqmqq gQextd">Powered by <a href="https://github.com/clinyong/cubi">Cubi</a>,  </span><span class="sc-dnqmqq gQextd">Hosted by <a href="https://pages.coding.me">Coding Pages</a></span></div></div></div>
    
      <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
              navigator.serviceWorker.register('/sw.js');
            });
          }
      </script>
      
    <script>
		
    </script>
    <script>
		var INIT_PROPS = {"content":{"meta":{"title":"Cubi 的由来","date":"2018.03.31"},"content":"\n博客建立到现在一年多，已经重构了两次，之前也写了两篇文章简单地介绍博客的构建过程\n\n*   [Hello World](https://blog.leodots.me/post/1-hello-world.html)\n*   [用 next.js 构建博客](https://blog.leodots.me/post/7-nextjs-static.html)\n\n在第二篇文章的末尾也提到，用 `next.js` 包含了很多功能，生成出来的静态文件也复杂得多。最直观的感受就是，用 `next.js` 构建完之后，用 [PageSpeed](https://developers.google.com/speed/pagespeed/insights/?hl=zh-CN) 测试出来的得分反而降低了。\n\n而用 `next.js` 的目的就是为了能用 React 来写博客页面，并且第一次加载的时候能有内容（其实就是 React 的服务器端渲染）。考虑清楚之后，觉得难度不大，加上想自己造造轮子，便写了 [Cubi](https://github.com/clinyong/cubi)，一个用 React 生成静态博客的工具。这个名字的由来，也是取自火影当中九尾的谐音。\n\n![](http://g.udn.com.tw/upfiles/B_ME/meatball2/PSN_PHOTO/615/f_17000615_1.JPG)\n\n写这个工具，主要碰到了两个问题\n\n*   怎样静态输出 React 组件\n*   怎样处理样式\n*   怎样处理路由\n\n### 静态输出 React 组件\n\n`react-dom` 这个包提供了一个 `renderToString` 的方法，可以把组件以字符串的形式输出\n\n```ts\nimport * as ReactDOMServer from \"react-dom/server\";\nimport Component from \"...\";\n\nconst ins = React.createElement(Component, props);\nconst componentStr = ReactDOMServer.renderToString(ins);\n\nconsole.log(componentStr);\n```\n\n只需要把输出的字符串，插入到我们的 HTML 模板里面，就可以正常显示了。输出完之后，还有一个问题，就是上面绑定的事件都没有了。这是因为 `renderToString` 只是做静态输出，并不会把事件绑定上去。还好 ReactDOM 提供了另外一个方法，(hydrate)[https://reactjs.org/docs/react-dom.html#hydrate]，来做这件事情。\n\n`hydrate` 的用法基本和 `render` 一样，官方的文档已经说的很清楚了\n\n&gt; Same as render(), but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup.\n\n博客总共有 3 个[入口文件](https://github.com/clinyong/blog/tree/master/src/view)，Cubi 读取了这三个入口文件之后，会通过一个 [Hydrate](https://github.com/clinyong/cubi/blob/master/src/ReactHydrate.ts) 的插件，在每个入口文件里面加多一句\n\n```ts\nReactDOM.funcName(&lt;componentName />, document.getElementById(\"app\"));\n```\n\n这里的 `componentName` 就是每个入口文件 `export default` 对应的组件名称，`funcName` 有两种情况，在开发模式下为 `render`，在编译发布的时候，是 `hydrate`。\n\n### 添加样式\n\n样式是采用 `styled-component`，这个库本身也是支持服务器端渲染，[官方文档](https://www.styled-components.com/docs/advanced#server-side-rendering) 也有很好的说明。`styled-component` 提供了一个 `getStyleTags`的 api，可以把整个页面用到的类都提取出来\n\n```ts\nimport * as ReactDOMServer from \"react-dom/server\";\nimport Component from \"...\";\nimport { ServerStyleSheet } from \"styled-components\";\n\nconst ins = React.createElement(Component, props);\nconst sheet = new ServerStyleSheet();\nReactDOMServer.renderToString(sheet.collectStyles(ins));\n\ninitStyles = sheet.getStyleTags();\nconsole.log(initStyles);\n```\n\n`initStyles` 就是整个组件，包括其子组件对应的样式，我们只需要把这部分直接插入到 HTML 模板的 head 头部就可以了。\n\n> 这里也比较偷懒，直接把 Cubi 和 `styled-component` 绑定在一起，使的要用 Cubi 去生成页面的话，样式一定采用 `styled-component`。更好的做法应该像\n> `next.js` 那样，可以自由选择第三方样式库。\n\n### 路由处理\n\n路由处理是比较麻烦的事情，在这里也是借鉴了 `next.js` 的做法。在 Cubi 的[配置文件](https://github.com/clinyong/blog/blob/master/cubi.config.js)里面，有个 `exportPathMap` 用于配置路由\n\n```js\n{\n    async exportPathMap() {\n        const files = await readArticles();\n        const pages = files.reduce(\n            (pages, file) =>\n                Object.assign({}, pages, {\n                    [file.link]: {\n                        page: \"post\",\n                        query: { content: file.result }\n                    }\n                }),\n            {}\n        );\n\n        return Object.assign({}, pages, {\n            index: {\n                page: \"index\",\n                query: {\n                    articles: files.slice(0, 10).map(item => ({\n                        link: item.link + \".html\",\n                        title: item.title\n                    }))\n                }\n            },\n            archive: {\n                page: \"index\",\n                query: {\n                    articles: files.map(item => ({\n                        link: item.link + \".html\",\n                        title: item.title\n                    }))\n                }\n            },\n            about: {\n                page: \"about\"\n            }\n        });\n    }\n}\n```\n\n`readArticles` 是把某个目录下面的文章全部读出来，转成一个 `pages` 对象。这个对象的每个 key 值就是文章的路径，比如这篇文章就是 `post/15-intro-cubi`。每个 key 对应的字段又是一个对象，这个对象里面的 `page` 是指定要选用哪个模板组件，`query` 是组件一开始加载的参数。\n\n`pages` 包含了所有的文章页面，除此之外还要再加上首页，归档和关于页面。上面这些就是博客的全部路由。\n\nCubi 内部是通过一个 HTML [插件](https://github.com/clinyong/cubi/blob/master/src/HTMLPlugin.ts)来处理路由的\n\n```ts\nconst routesMap = await exportPathMap();\n\nObject.keys(routesMap).forEach(k => {\n    const routeItem = routesMap[k];\n    const entryItem = entry[routeItem.page] as string;\n\n    if (entryItem) {\n        const entryPath = findEntryPath(entryItem);\n        const props = routeItem.query;\n\n        if (entryPath) {\n            let initContent = \"\";\n            let initStyles = \"\";\n            let initProps = props ? JSON.stringify(props) : \"{}\";\n            let entryList = [routeItem.page + \".js\"];\n            if (isProd) {\n                // 静态输出组件，拿到 initContent 和 initStyles\n                const sheet = new ServerStyleSheet();\n                const Component = require(entryPath).default;\n                const ins = React.createElement(Component, props);\n                initContent = ReactDOMServer.renderToString(\n                    sheet.collectStyles(ins)\n                );\n                initStyles = sheet.getStyleTags();\n            }\n        }\n\n        const content = ejs.render(templateContent, {\n            initProps\n            // 传进模板里面的各种参数\n        });\n\n        compilation.assets[`${k}.html`] = {\n            source: () => content,\n            size: () => content.length\n        };\n    }\n});\n```\n\n这个插件会遍历整个路由对象，根据每个路由上面定义的 `page` 字段找到对应的模板组件路径 `entryPath`，然后就是之前说的，静态输出这个组件，拿到对应的内容和样式，插入到 ejs 的模板里面。然后再把模板生成的内容，添加到 webpack 输出的 `assets` 里面。\n\n当在服务器端静态输出组件的时候，我们直接把 `initProps` 传给 `React.createElement`，让组件能正常输出。但是当页面加载完，我们调用 `ReactDOM.render` 或者 `ReactDOM.hydrate` 时，怎样把参数传给组件呢？这里会把要初始化的 props 传给 ejs 模板，[模板里面](https://github.com/clinyong/cubi/blob/master/config/template.html#L17)会创建一个全局变量 `INIT_PROPS`，最上面介绍的 [Hydrate](https://github.com/clinyong/cubi/blob/master/src/ReactHydrate.ts#L64) 插件会在创建组件的时候，去读取这个值，类似下面这样\n\n```tsx\nReactDOM.hydrate(\n    React.createElement(Post, INIT_PROPS),\n    document.getElementById(\"app\")\n);\n```\n\n上面就是 Cubi 基本的构建过程，更详细的实现，可以看下项目的源码。\n"}};
    </script>
    
    <script src=/js/vendors.f58cabc9.dll.js></script>
    
    <script src=/js/__post.6c7dc1cb.dll.js></script>
    
    <script src=/js/post.9e5c2604.js></script>
    
</body>

</html>
