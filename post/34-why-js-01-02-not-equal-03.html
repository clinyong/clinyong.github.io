<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    
      <title>
        为什么 JS 中 0.1 加 0.2 不等于 0.3 | Leodots
      </title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style type="text/css" data-styled-components="djiuUw ehFhRk bjznky ehsBOr cKUUOL bUfeR dQozFt bxrUCS hBdBXi gQextd" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {}

.djiuUw{display:block;text-align:center;padding:0;margin:0;padding-top:30px;list-style:none;height:55px;margin-left:calc(100vw - 100%);}@media screen and (max-width:770px){.djiuUw{display:none;}}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {}

.ehFhRk{text-align:center;font-size:18px;margin:0 25px;display:inline-block;}.ehFhRk:hover{border-bottom:2px solid #222;}.ehFhRk > a{-webkit-text-decoration:none;text-decoration:none;color:#222;}
/* sc-component-id: sc-htpNat */
.sc-htpNat {}

.bjznky{position:relative;}@media screen and (min-width:770px){.bjznky{display:none;}}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {}

.ehsBOr{text-align:center;background-color:#464d5c;color:#fff;padding:40px 10px;font-size:40px;}
/* sc-component-id: sc-ifAKCX */
.sc-ifAKCX {}

.cKUUOL{color:#bee178;}
/* sc-component-id: sc-EHOje */
.sc-EHOje {}

.bUfeR{position:absolute;right:0px;padding:19px 19px;top:0px;border-radius:50%;background-color:transparent;border-color:transparent;-webkit-transition:0.5s background-color;transition:0.5s background-color;}
/* sc-component-id: sc-bZQynM */
.sc-bZQynM {}

.dQozFt{height:2px;width:18px;margin-bottom:3px;display:block;background-color:#bee178;}
/* sc-component-id: sc-gzVnrw */
.sc-gzVnrw {}

.bxrUCS{position:absolute;right:20px;top:42px;width:150px;height:125px;background-color:#fff;box-shadow:rgba(0,0,0,0.117647) 0 1px 6px, rgba(0,0,0,0.239216) 0 1px 4px;-webkit-transition:0.2s;transition:0.2s;overflow:hidden;padding:10px 0;}.bxrUCS > li{list-style:none;}.bxrUCS > li > a{-webkit-text-decoration:none;text-decoration:none;color:#777;display:block;padding:10px 20px;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {}

.hBdBXi{position:absolute;bottom:20px;left:0;right:0;text-align:center;font-size:12px;}
/* sc-component-id: sc-dnqmqq */
.sc-dnqmqq {}

.gQextd{color:#999;}.gQextd > a{color:#bee178 !important;-webkit-text-decoration:none;text-decoration:none;}@media screen and (min-width:770px){.gQextd > a{color:#108ee9 !important;-webkit-text-decoration:underline;text-decoration:underline;}}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1576189413 */
html{position:relative;background-color:#464d5c;font-family:'PingFang SC','Hiragino Sans GB','Microsoft Yahei','WenQuanYi Micro Hei',sans-serif;}@media screen and (min-width:770px){html{background-color:#ECF0F1;}}html,body{min-height:100vh;margin:0;padding:0;}#app{min-height:100vh;}
</style><style type="text/css" data-styled-components="gkwKrD gIWTme iLKjzi fCjyQ kqQANZ frgWBf OaFaI" data-styled-components-is-local="true">/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {}

.gkwKrD{position:relative;min-height:100vh;}
/* sc-component-id: sc-gZMcBi */
.sc-gZMcBi {}

.gIWTme{padding-bottom:60px;}@media screen and (min-width:770px){.gIWTme{padding:0px 0 100px;margin-left:calc(100vw - 100%);}}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {}

.iLKjzi{padding:20px 15px 25px;background-color:#fff;}@media screen and (min-width:770px){.iLKjzi{box-sizing:border-box;width:768px;margin:0 auto;padding-left:40px;padding-right:40px;box-shadow:0px 30px 60px 0px #d3dde2;}}
/* sc-component-id: sc-VigVT */
.sc-VigVT {}

.kqQANZ{margin-top:0;margin-bottom:30px;text-align:center;font-size:24px;}@media screen and (min-width:770px){.kqQANZ{font-size:30px;}}
/* sc-component-id: sc-jTzLTM */
.sc-jTzLTM {}

.frgWBf{text-align:center;color:#999;margin-top:50px;font-size:12px;-webkit-text-decoration:underline;text-decoration:underline;}
/* sc-component-id: sc-fjdhpX */
.sc-fjdhpX {}

.OaFaI{background-color:#fff;padding-top:60px;}
/* sc-component-id: sc-jzJRlG */
.sc-jzJRlG {}

.fCjyQ{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.fCjyQ{min-height:500px;}.fCjyQ a:hover{-webkit-text-decoration:underline;text-decoration:underline;cursor:pointer;}}.fCjyQ a{color:#3194d0;}.fCjyQ p,.fCjyQ li{line-height:1.8;}.fCjyQ img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.fCjyQ img{max-width:500px;}}.fCjyQ code{background:#f2f2f2;padding:2px 5px;}.fCjyQ pre{background:#f2f2f2;padding:20px;overflow-x:auto;line-height:1.8;}.fCjyQ pre > code{padding:0;}.fCjyQ blockquote{margin-left:0;padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}
</style>
</head>

<body>
    <div id="app"><div class="sc-iwsKbI gkwKrD" data-reactroot=""><div><ul class="sc-bdVaJa djiuUw"><li class="sc-bwzfXH ehFhRk"><a href="/">首页</a></li><li class="sc-bwzfXH ehFhRk"><a href="/archive.html">归档</a></li><li class="sc-bwzfXH ehFhRk"><a href="/about.html">关于</a></li></ul><div class="sc-htpNat bjznky"><div class="sc-bxivhb ehsBOr"><span class="sc-ifAKCX cKUUOL">&lt;Leodots /&gt;</span></div><button class="sc-EHOje bUfeR"><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span></button><ul class="sc-gzVnrw bxrUCS" style="width:0;height:0"><li><a href="/">首页</a></li><li><a href="/archive.html">归档</a></li><li><a href="/about.html">关于</a></li></ul></div></div><div class="sc-gZMcBi gIWTme"><div class="sc-gqjmRU iLKjzi"><div class="sc-jzJRlG fCjyQ"><div class="sc-VigVT kqQANZ">为什么 JS 中 0.1 加 0.2 不等于 0.3</div><div class="sc-jzJRlG fCjyQ"><p>又是一个古老的话题。最近辞职在家看书，写了很多篇博客都是一些常见的面试题。嗯，作为一个稍微比较有追求的程序员，是不应该去死记硬背那些题目的。真正去理解这些题目，对实际开发也是很有帮助的。比如这篇要写的内容，因为之前公司是做电商的，所以经常会遇到这个问题。</p>
<p>首先要知道 JS 的数值表示规则。JS 中只有 Number 这一数值类型，整数和小数都是统一用这种类型去表示的。而 Number 用的是 <a href="https://www.wikiwand.com/zh-hans/IEEE_754">IEEE 754</a> 64 位双精度编码，所以实际上采用 754 这个标准的语言都存在这个问题。</p>
<p>具体标准的内容可以看看上面的链接，这里再推荐两个还不错的教程</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=8afbTaA-gOQ">https://www.youtube.com/watch?v=8afbTaA-gOQ</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html</a></li>
</ul>
<p>看完之后，基本就知道怎样把一个数用 IEEE 754 去表示了。然后来看下题目中的两个小数，随便找个 JS 环境，运行 <code>0.1 + 0.2</code>，可以得到下面的结果。</p>
<pre><code>0.30000000000000004
</code></pre>
<p>下面就来分析下这个看起来很奇怪的数字是怎么来的。先把 0.1 换成二进制表示</p>
<pre><code>0.0 0011 0011 0011 ...
</code></pre>
<p>为了直观一点，用空格区分开每组重复的数字。这里已经可以看到 0.1 用二进制表示的位数是无限的，所以是没办法把结果完整地保存下来。IEEE 754 会把这种情况做下取整，就得到下面这个 64 位的结果。</p>
<pre><code>0-01111111011-1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
</code></pre>
<p>上面的 <code>-</code> 和空格这里只是为了显示得直观一点。可能会有疑问为什么最后 4 位是 <code>1010</code> 不是 <code>1001</code>？这是 IEEE 754 的取整规则，如果溢出的第一位是 <code>1</code>，则前面的数要加上 1。比如 <code>10001</code> 取整 4 位就变成 <code>1001</code>。</p>
<p>按照上面的规则转换下 0.2</p>
<pre><code>0-01111111100-1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
</code></pre>
<p>对于这种形式的两个数要怎样相加呢？一开始我是直接把每个二进制数相加，算了好久发现果然不对。后面看到了一个教程</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=KiWz-mGFqHI">https://www.youtube.com/watch?v=KiWz-mGFqHI</a></li>
</ul>
<p>实际上当要做计算的时候，需要把二进制用下面的形式表示</p>
<p><img src="http://ol07x5ssf.bkt.clouddn.com/chart.png" alt="" /></p>
<p>对于 0.1，对应的 <code>S</code> 为 0，<code>M</code> 为 <code>1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010</code>，<code>E</code> 为 -4。对于 0.2，则为 0, <code>1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010</code>，-3。转换之后就可以直接做运算了，把得到的结果再转成 IEEE 754 标准的形式</p>
<pre><code>0-01111111101-0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100
</code></pre>
<p>转成十进制的话，就是 <code>0.30000000000000004</code>。</p>
<h3 id="">后记</h3>
<p>本来以为半天时间就能搞定这个知识点，最后面花了大概两天的时间，还写了一个相互转换的<a href="https://github.com/clinyong/ieee754">工具</a>。写完之后发现另外一篇<a href="https://github.com/camsong/blog/issues/9">文章</a>也把这个过程介绍得很详细，感觉比我这篇写得好，所以就当作是整理和总结吧。</p>
<p>（完）</p></div><div class="sc-jTzLTM frgWBf">2018.08.03</div></div><div class="sc-fjdhpX OaFaI" id="disqus_thread"></div></div></div><div class="sc-htoDjs hBdBXi"><span class="sc-dnqmqq gQextd">Powered by <a href="https://github.com/clinyong/cubi">Cubi</a>,  </span><span class="sc-dnqmqq gQextd">Hosted by <a href="https://pages.coding.me">Coding Pages</a></span></div></div></div>
    
      <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
              navigator.serviceWorker.register('/sw.js');
            });
          }
      </script>
      
    <script>
		
    </script>
    <script>
		var INIT_PROPS = {"content":{"meta":{"title":"为什么 JS 中 0.1 加 0.2 不等于 0.3","date":"2018.08.03"},"content":"\n又是一个古老的话题。最近辞职在家看书，写了很多篇博客都是一些常见的面试题。嗯，作为一个稍微比较有追求的程序员，是不应该去死记硬背那些题目的。真正去理解这些题目，对实际开发也是很有帮助的。比如这篇要写的内容，因为之前公司是做电商的，所以经常会遇到这个问题。\n\n首先要知道 JS 的数值表示规则。JS 中只有 Number 这一数值类型，整数和小数都是统一用这种类型去表示的。而 Number 用的是 [IEEE 754](https://www.wikiwand.com/zh-hans/IEEE_754) 64 位双精度编码，所以实际上采用 754 这个标准的语言都存在这个问题。\n\n具体标准的内容可以看看上面的链接，这里再推荐两个还不错的教程\n\n- &lt;https://www.youtube.com/watch?v=8afbTaA-gOQ&gt;\n- &lt;http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html>\n\n看完之后，基本就知道怎样把一个数用 IEEE 754 去表示了。然后来看下题目中的两个小数，随便找个 JS 环境，运行 `0.1 + 0.2`，可以得到下面的结果。\n\n```\n0.30000000000000004\n```\n\n下面就来分析下这个看起来很奇怪的数字是怎么来的。先把 0.1 换成二进制表示\n\n```\n0.0 0011 0011 0011 ...\n```\n\n为了直观一点，用空格区分开每组重复的数字。这里已经可以看到 0.1 用二进制表示的位数是无限的，所以是没办法把结果完整地保存下来。IEEE 754 会把这种情况做下取整，就得到下面这个 64 位的结果。\n\n```\n0-01111111011-1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010\n```\n上面的 `-` 和空格这里只是为了显示得直观一点。可能会有疑问为什么最后 4 位是 `1010` 不是 `1001`？这是 IEEE 754 的取整规则，如果溢出的第一位是 `1`，则前面的数要加上 1。比如 `10001` 取整 4 位就变成 `1001`。\n\n按照上面的规则转换下 0.2\n\n```\n0-01111111100-1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010\n```\n\n对于这种形式的两个数要怎样相加呢？一开始我是直接把每个二进制数相加，算了好久发现果然不对。后面看到了一个教程\n\n- &lt;https://www.youtube.com/watch?v=KiWz-mGFqHI>\n\n实际上当要做计算的时候，需要把二进制用下面的形式表示\n\n![](http://ol07x5ssf.bkt.clouddn.com/chart.png)\n\n对于 0.1，对应的 `S` 为 0，`M` 为 `1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010`，`E` 为 -4。对于 0.2，则为 0, `1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010`，-3。转换之后就可以直接做运算了，把得到的结果再转成 IEEE 754 标准的形式\n\n```\n0-01111111101-0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100\n```\n\n转成十进制的话，就是 `0.30000000000000004`。\n\n### 后记\n\n本来以为半天时间就能搞定这个知识点，最后面花了大概两天的时间，还写了一个相互转换的[工具](https://github.com/clinyong/ieee754)。写完之后发现另外一篇[文章](https://github.com/camsong/blog/issues/9)也把这个过程介绍得很详细，感觉比我这篇写得好，所以就当作是整理和总结吧。\n\n（完）\n"}};
    </script>
    
    <script src=/js/vendors.094c268b.dll.js></script>
    
    <script src=/js/__post.a85ba19a.dll.js></script>
    
    <script src=/js/post.cb81a6af.js></script>
    
</body>

</html>
