<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    
      <title>
        用 next.js 构建博客 | Leodots
      </title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style type="text/css" data-styled-components="djiuUw ehFhRk bjznky ehsBOr cKUUOL bUfeR dQozFt bxrUCS hBdBXi gQextd" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {}

.djiuUw{display:block;text-align:center;padding:0;margin:0;padding-top:30px;list-style:none;height:55px;margin-left:calc(100vw - 100%);}@media screen and (max-width:770px){.djiuUw{display:none;}}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {}

.ehFhRk{text-align:center;font-size:18px;margin:0 25px;display:inline-block;}.ehFhRk:hover{border-bottom:2px solid #222;}.ehFhRk > a{-webkit-text-decoration:none;text-decoration:none;color:#222;}
/* sc-component-id: sc-htpNat */
.sc-htpNat {}

.bjznky{position:relative;}@media screen and (min-width:770px){.bjznky{display:none;}}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {}

.ehsBOr{text-align:center;background-color:#464d5c;color:#fff;padding:40px 10px;font-size:40px;}
/* sc-component-id: sc-ifAKCX */
.sc-ifAKCX {}

.cKUUOL{color:#bee178;}
/* sc-component-id: sc-EHOje */
.sc-EHOje {}

.bUfeR{position:absolute;right:0px;padding:19px 19px;top:0px;border-radius:50%;background-color:transparent;border-color:transparent;-webkit-transition:0.5s background-color;transition:0.5s background-color;}
/* sc-component-id: sc-bZQynM */
.sc-bZQynM {}

.dQozFt{height:2px;width:18px;margin-bottom:3px;display:block;background-color:#bee178;}
/* sc-component-id: sc-gzVnrw */
.sc-gzVnrw {}

.bxrUCS{position:absolute;right:20px;top:42px;width:150px;height:125px;background-color:#fff;box-shadow:rgba(0,0,0,0.117647) 0 1px 6px, rgba(0,0,0,0.239216) 0 1px 4px;-webkit-transition:0.2s;transition:0.2s;overflow:hidden;padding:10px 0;}.bxrUCS > li{list-style:none;}.bxrUCS > li > a{-webkit-text-decoration:none;text-decoration:none;color:#777;display:block;padding:10px 20px;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {}

.hBdBXi{position:absolute;bottom:20px;left:0;right:0;text-align:center;font-size:12px;}
/* sc-component-id: sc-dnqmqq */
.sc-dnqmqq {}

.gQextd{color:#999;}.gQextd > a{color:#bee178 !important;-webkit-text-decoration:none;text-decoration:none;}@media screen and (min-width:770px){.gQextd > a{color:#108ee9 !important;-webkit-text-decoration:underline;text-decoration:underline;}}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1576189413 */
html{position:relative;background-color:#464d5c;font-family:'PingFang SC','Hiragino Sans GB','Microsoft Yahei','WenQuanYi Micro Hei',sans-serif;}@media screen and (min-width:770px){html{background-color:#ECF0F1;}}html,body{min-height:100vh;margin:0;padding:0;}#app{min-height:100vh;}
</style><style type="text/css" data-styled-components="gkwKrD gIWTme iLKjzi fCjyQ kqQANZ frgWBf OaFaI" data-styled-components-is-local="true">/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {}

.gkwKrD{position:relative;min-height:100vh;}
/* sc-component-id: sc-gZMcBi */
.sc-gZMcBi {}

.gIWTme{padding-bottom:60px;}@media screen and (min-width:770px){.gIWTme{padding:0px 0 100px;margin-left:calc(100vw - 100%);}}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {}

.iLKjzi{padding:20px 15px 25px;background-color:#fff;}@media screen and (min-width:770px){.iLKjzi{box-sizing:border-box;width:768px;margin:0 auto;padding-left:40px;padding-right:40px;box-shadow:0px 30px 60px 0px #d3dde2;}}
/* sc-component-id: sc-VigVT */
.sc-VigVT {}

.kqQANZ{margin-top:0;margin-bottom:30px;text-align:center;font-size:24px;}@media screen and (min-width:770px){.kqQANZ{font-size:30px;}}
/* sc-component-id: sc-jTzLTM */
.sc-jTzLTM {}

.frgWBf{text-align:center;color:#999;margin-top:50px;font-size:12px;-webkit-text-decoration:underline;text-decoration:underline;}
/* sc-component-id: sc-fjdhpX */
.sc-fjdhpX {}

.OaFaI{background-color:#fff;padding-top:60px;}
/* sc-component-id: sc-jzJRlG */
.sc-jzJRlG {}

.fCjyQ{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.fCjyQ{min-height:500px;}.fCjyQ a:hover{-webkit-text-decoration:underline;text-decoration:underline;cursor:pointer;}}.fCjyQ a{color:#3194d0;}.fCjyQ p,.fCjyQ li{line-height:1.8;}.fCjyQ img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.fCjyQ img{max-width:500px;}}.fCjyQ code{background:#f2f2f2;padding:2px 5px;}.fCjyQ pre{background:#f2f2f2;padding:20px;overflow-x:auto;line-height:1.8;}.fCjyQ pre > code{padding:0;}.fCjyQ blockquote{margin-left:0;padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}
</style>
</head>

<body>
    <div id="app"><div class="sc-iwsKbI gkwKrD" data-reactroot=""><div><ul class="sc-bdVaJa djiuUw"><li class="sc-bwzfXH ehFhRk"><a href="/">首页</a></li><li class="sc-bwzfXH ehFhRk"><a href="/archive.html">归档</a></li><li class="sc-bwzfXH ehFhRk"><a href="/about.html">关于</a></li></ul><div class="sc-htpNat bjznky"><div class="sc-bxivhb ehsBOr"><span class="sc-ifAKCX cKUUOL">&lt;Leodots /&gt;</span></div><button class="sc-EHOje bUfeR"><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span><span class="sc-bZQynM dQozFt"></span></button><ul class="sc-gzVnrw bxrUCS" style="width:0;height:0"><li><a href="/">首页</a></li><li><a href="/archive.html">归档</a></li><li><a href="/about.html">关于</a></li></ul></div></div><div class="sc-gZMcBi gIWTme"><div class="sc-gqjmRU iLKjzi"><div class="sc-jzJRlG fCjyQ"><div class="sc-VigVT kqQANZ">用 next.js 构建博客</div><div class="sc-jzJRlG fCjyQ"><p>之前的博客是通过模板去生成 HTML，模板引擎用的是 <a href="https://github.com/aui/art-template">art-template</a>。用 PostCSS 去处理 <code>scss</code> 文件，手动去压缩生成后的静态文件。</p>
<p>传统的静态博客生成工具大概都是这样子。平时工作中都是在用 <code>React</code>，所以也一直想着能把上面的流程都改成用 <code>React</code> 来构建。刚好前不久，<code>next.js</code> 出了 <a href="https://zeit.co/blog/next3">3.0</a> 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。
当然社区里面已经有基于 <code>next.js</code> 的博客生成工具，不过还是想自己去实现一套。</p>
<p>根据官方文档，安装需要的依赖，这里的 css 方案选择现在比较热门的 <a href="https://www.styled-components.com/">styled-components</a>。<code>pages</code> 目录下对应着每个页面文件，比如 <code>index.js</code> 就会生成 <code>index.html</code>。我们这里需要三个文件</p>
<ul>
<li>_document.js</li>
<li>index.js</li>
<li>post.js</li>
</ul>
<p><code>_document.js</code> 用来改写 <code>&lt;html&gt;</code>，<code>&lt;body&gt;</code> 的默认行为。另外两个文件，一个是首页，一个是文章页面。因为要生成静态文件，所以这里要额外的配置一下 <code>next.js</code>。配置的内容放在 <code>next.config.js</code> 中</p>
<pre><code class="js language-js">const readArticles = require("./lib/readArticles");

module.exports = {
    async exportPathMap() {
        const files = await readArticles();
        const pages = files.reduce(
            (pages, file) =&gt;
                Object.assign({}, pages, {
                    [file.link]: {
                        page: "/post",
                        query: { content: file.result }
                    }
                }),
            {}
        );

        return Object.assign({}, pages, {
            "/": {
                page: "/",
                query: {
                    articles: files.map(item =&gt; ({
                        link: item.link,
                        title: item.title
                    }))
                }
            }
        });
    }
};
</code></pre>
<p>先来看下每个路由对象，这里以首页和某一篇文章为例</p>
<pre><code class="js language-js">{
    "/": {                
        page: "/",
        query: {
            articles: files.map(item =&gt; ({
                link: item.link,
                title: item.title
            }))
        }
    },
    "/post/1-hello-world/": {
        page: "/post",
        query: { content: file.result }
    },
    // more...
}
</code></pre>
<p>每个 <code>key</code> 是具体的路径，<code>page</code> 是选择对应了哪个组件，比如这里的首页是 <code>pages</code> 目录下的 <code>index.js</code> 组件。<code>query</code> 是要传给组件的参数，这个参数会在组件的 <code>getInitialProps</code> 方法接收。比如首页这个组件</p>
<pre><code class="js language-js">export default class Index extends React.PureComponent {
    static async getInitialProps({ query }) {
        return { articles: query.articles || [] };
    }

    render() {
        return (
            &lt;ul&gt;
                {
                   articles.map(item =&gt; (
                       &lt;li&gt;
                            &lt;a href={item.link}&gt;{item.title}&lt;/a&gt;
                       &lt;/li&gt;
                   ))
                }
            &lt;/ul&gt;
        )
    }
}
</code></pre>
<p><code>getInitialProps</code> 这个方法会在生成 HTML 的时候执行。最早的时候，是以下面的方式去读取所有的文章</p>
<pre><code class="js language-js">import fs from "fs-extra";

export default class Index extends React.PureComponent {
    static async getInitialProps() {
        const files = await fs.readDir(/*...*/)
        return { articles: query.articles || [] };
    }

    render() {
        // ...
    }
}
</code></pre>
<p>后面编译的时候总是会报各种奇怪的错误，考虑到 <code>fs</code> 并不是浏览器和服务器通用的模块，所以最后面还是把读取所有文章的操作放到了 <code>next.config.js</code> 中。上面这样的配置，编译成 HTML 已经没有什么大问题了。然后开始来考虑开发模式。</p>
<p>直接用 <code>next.js</code> 的开发模式是不可行的，比如我们的首页组件这些都是需要接受路由参数的，而当我们直接访问 <code>http://localhost:3000/</code> 是没有带参数的。所以需要重写一下 devServer</p>
<pre><code class="js language-js">const files = await readArticles();
const server = express();
const app = next();

server.get("/post/:name", (req, res) =&gt; {
    const file = files.find(item =&gt; item.link === req.path);
    return app.render(req, res, "/post", {
        content: file.result
    });
});

server.get("*", (req, res) =&gt; {
    return app.render(req, res, "/", {
        articles: files.map(item =&gt; ({
            link: item.link,
            title: item.title
        }))
    });
});
</code></pre>
<p>这里同样是伪代码，用来说明一下 <code>express</code> 的路由配置。可以看到，这里调用 <code>app.render</code>，手动给组件传所需要的参数。</p>
<p>配置到这里之后，基本整个流程都能跑通了，看下生成出来的静态文件，比以前复杂许多。不过这也很正常，<code>next.js</code> 包含了很多功能，不止用来生成博客。后期也会考虑自己实现一个简易的 <code>React</code> 服务器端渲染方案来替代 <code>next.js</code>。</p></div><div class="sc-jTzLTM frgWBf">2017.08.26</div></div><div class="sc-fjdhpX OaFaI" id="disqus_thread"></div></div></div><div class="sc-htoDjs hBdBXi"><span class="sc-dnqmqq gQextd">Powered by <a href="https://github.com/clinyong/cubi">Cubi</a>,  </span><span class="sc-dnqmqq gQextd">Hosted by <a href="https://pages.coding.me">Coding Pages</a></span></div></div></div>
    
      <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
              navigator.serviceWorker.register('/sw.js');
            });
          }
      </script>
      
    <script>
		
    </script>
    <script>
		var INIT_PROPS = {"content":{"meta":{"title":"用 next.js 构建博客","date":"2017.08.26"},"content":"\n之前的博客是通过模板去生成 HTML，模板引擎用的是 [art-template](https://github.com/aui/art-template)。用 PostCSS 去处理 `scss` 文件，手动去压缩生成后的静态文件。\n\n传统的静态博客生成工具大概都是这样子。平时工作中都是在用 `React`，所以也一直想着能把上面的流程都改成用 `React` 来构建。刚好前不久，`next.js` 出了 [3.0](https://zeit.co/blog/next3) 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。\n当然社区里面已经有基于 `next.js` 的博客生成工具，不过还是想自己去实现一套。\n\n根据官方文档，安装需要的依赖，这里的 css 方案选择现在比较热门的 [styled-components](https://www.styled-components.com/)。`pages` 目录下对应着每个页面文件，比如 `index.js` 就会生成 `index.html`。我们这里需要三个文件\n\n- _document.js\n- index.js\n- post.js\n\n`_document.js` 用来改写 `&lt;html&gt;`，`&lt;body>` 的默认行为。另外两个文件，一个是首页，一个是文章页面。因为要生成静态文件，所以这里要额外的配置一下 `next.js`。配置的内容放在 `next.config.js` 中\n\n```js\nconst readArticles = require(\"./lib/readArticles\");\n\nmodule.exports = {\n\tasync exportPathMap() {\n\t\tconst files = await readArticles();\n\t\tconst pages = files.reduce(\n\t\t\t(pages, file) =>\n\t\t\t\tObject.assign({}, pages, {\n\t\t\t\t\t[file.link]: {\n\t\t\t\t\t\tpage: \"/post\",\n\t\t\t\t\t\tquery: { content: file.result }\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t{}\n\t\t);\n\n\t\treturn Object.assign({}, pages, {\n\t\t\t\"/\": {\n\t\t\t\tpage: \"/\",\n\t\t\t\tquery: {\n\t\t\t\t\tarticles: files.map(item => ({\n\t\t\t\t\t\tlink: item.link,\n\t\t\t\t\t\ttitle: item.title\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n```\n\n先来看下每个路由对象，这里以首页和某一篇文章为例\n\n```js\n{\n    \"/\": {\t\t\t\t\n        page: \"/\",\n        query: {\n            articles: files.map(item => ({\n                link: item.link,\n                title: item.title\n            }))\n        }\n    },\n    \"/post/1-hello-world/\": {\n        page: \"/post\",\n        query: { content: file.result }\n    },\n    // more...\n}\n```\n\n每个 `key` 是具体的路径，`page` 是选择对应了哪个组件，比如这里的首页是 `pages` 目录下的 `index.js` 组件。`query` 是要传给组件的参数，这个参数会在组件的 `getInitialProps` 方法接收。比如首页这个组件\n\n```js\nexport default class Index extends React.PureComponent {\n\tstatic async getInitialProps({ query }) {\n\t\treturn { articles: query.articles || [] };\n\t}\n\n    render() {\n        return (\n            &lt;ul>\n                {\n                   articles.map(item => (\n                       &lt;li>\n                            &lt;a href={item.link}>{item.title}&lt;/a>\n                       &lt;/li>\n                   ))\n                }\n            &lt;/ul>\n        )\n    }\n}\n```\n\n`getInitialProps` 这个方法会在生成 HTML 的时候执行。最早的时候，是以下面的方式去读取所有的文章\n\n```js\nimport fs from \"fs-extra\";\n\nexport default class Index extends React.PureComponent {\n\tstatic async getInitialProps() {\n        const files = await fs.readDir(/*...*/)\n\t\treturn { articles: query.articles || [] };\n\t}\n\n    render() {\n        // ...\n    }\n}\n```\n\n后面编译的时候总是会报各种奇怪的错误，考虑到 `fs` 并不是浏览器和服务器通用的模块，所以最后面还是把读取所有文章的操作放到了 `next.config.js` 中。上面这样的配置，编译成 HTML 已经没有什么大问题了。然后开始来考虑开发模式。\n\n直接用 `next.js` 的开发模式是不可行的，比如我们的首页组件这些都是需要接受路由参数的，而当我们直接访问 `http://localhost:3000/` 是没有带参数的。所以需要重写一下 devServer\n\n```js\nconst files = await readArticles();\nconst server = express();\nconst app = next();\n\nserver.get(\"/post/:name\", (req, res) => {\n    const file = files.find(item => item.link === req.path);\n    return app.render(req, res, \"/post\", {\n        content: file.result\n    });\n});\n\nserver.get(\"*\", (req, res) => {\n    return app.render(req, res, \"/\", {\n        articles: files.map(item => ({\n            link: item.link,\n            title: item.title\n        }))\n    });\n});\n```\n\n这里同样是伪代码，用来说明一下 `express` 的路由配置。可以看到，这里调用 `app.render`，手动给组件传所需要的参数。\n\n配置到这里之后，基本整个流程都能跑通了，看下生成出来的静态文件，比以前复杂许多。不过这也很正常，`next.js` 包含了很多功能，不止用来生成博客。后期也会考虑自己实现一个简易的 `React` 服务器端渲染方案来替代 `next.js`。\n"}};
    </script>
    
    <script src=/js/vendors.f58cabc9.dll.js></script>
    
    <script src=/js/__post.6c7dc1cb.dll.js></script>
    
    <script src=/js/post.9e5c2604.js></script>
    
</body>

</html>
